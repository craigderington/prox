
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/craigderington/prox/cmd/daemon.go (0.0%)</option>
				
				<option value="file1">github.com/craigderington/prox/cmd/delete.go (0.0%)</option>
				
				<option value="file2">github.com/craigderington/prox/cmd/helpers.go (0.0%)</option>
				
				<option value="file3">github.com/craigderington/prox/cmd/init.go (0.0%)</option>
				
				<option value="file4">github.com/craigderington/prox/cmd/list.go (0.0%)</option>
				
				<option value="file5">github.com/craigderington/prox/cmd/logs.go (0.0%)</option>
				
				<option value="file6">github.com/craigderington/prox/cmd/output.go (0.0%)</option>
				
				<option value="file7">github.com/craigderington/prox/cmd/restart.go (0.0%)</option>
				
				<option value="file8">github.com/craigderington/prox/cmd/root.go (0.0%)</option>
				
				<option value="file9">github.com/craigderington/prox/cmd/start.go (0.0%)</option>
				
				<option value="file10">github.com/craigderington/prox/cmd/startall.go (0.0%)</option>
				
				<option value="file11">github.com/craigderington/prox/cmd/stop.go (0.0%)</option>
				
				<option value="file12">github.com/craigderington/prox/internal/banner/banner.go (0.0%)</option>
				
				<option value="file13">github.com/craigderington/prox/internal/config/autodiscover.go (0.0%)</option>
				
				<option value="file14">github.com/craigderington/prox/internal/config/config.go (92.7%)</option>
				
				<option value="file15">github.com/craigderington/prox/internal/daemon/client.go (0.0%)</option>
				
				<option value="file16">github.com/craigderington/prox/internal/daemon/server.go (0.0%)</option>
				
				<option value="file17">github.com/craigderington/prox/internal/logs/logger.go (0.0%)</option>
				
				<option value="file18">github.com/craigderington/prox/internal/logs/merger.go (0.0%)</option>
				
				<option value="file19">github.com/craigderington/prox/internal/manager/shared.go (0.0%)</option>
				
				<option value="file20">github.com/craigderington/prox/internal/process/manager.go (61.4%)</option>
				
				<option value="file21">github.com/craigderington/prox/internal/process/metrics.go (0.0%)</option>
				
				<option value="file22">github.com/craigderington/prox/internal/process/persistence.go (0.0%)</option>
				
				<option value="file23">github.com/craigderington/prox/internal/process/types.go (0.0%)</option>
				
				<option value="file24">github.com/craigderington/prox/internal/storage/storage.go (57.6%)</option>
				
				<option value="file25">github.com/craigderington/prox/internal/tui/app.go (0.0%)</option>
				
				<option value="file26">github.com/craigderington/prox/internal/tui/dashboard.go (0.0%)</option>
				
				<option value="file27">github.com/craigderington/prox/internal/tui/logs.go (0.0%)</option>
				
				<option value="file28">github.com/craigderington/prox/internal/tui/monitor.go (0.0%)</option>
				
				<option value="file29">github.com/craigderington/prox/internal/tui/styles.go (0.0%)</option>
				
				<option value="file30">github.com/craigderington/prox/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cmd

import (
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "time"

        "github.com/craigderington/prox/internal/daemon"
        "github.com/craigderington/prox/internal/process"
        "github.com/spf13/cobra"
)

var daemonCmd = &amp;cobra.Command{
        Use:   "daemon",
        Short: "Manage the prox daemon",
        Long:  `Start, stop, or check status of the background prox daemon for auto-restart`,
}

var daemonStartCmd = &amp;cobra.Command{
        Use:   "start",
        Short: "Start the prox daemon",
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                // Check if already running
                client, err := daemon.NewClient()
                if err != nil </span><span class="cov0" title="0">{
                        PrintError("Failed to create client: %v", err)
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">if client.IsRunning() </span><span class="cov0" title="0">{
                        PrintWarning("Daemon already running")
                        return
                }</span>

                // Get executable path
                <span class="cov0" title="0">exePath, err := os.Executable()
                if err != nil </span><span class="cov0" title="0">{
                        PrintError("Failed to get executable path: %v", err)
                        os.Exit(1)
                }</span>

                // Start daemon in background
                <span class="cov0" title="0">daemonCmd := exec.Command(exePath, "daemon", "run")
                daemonCmd.Stdout = nil
                daemonCmd.Stderr = nil
                daemonCmd.Stdin = nil

                if err := daemonCmd.Start(); err != nil </span><span class="cov0" title="0">{
                        PrintError("Failed to start daemon: %v", err)
                        os.Exit(1)
                }</span>

                // Detach from parent
                <span class="cov0" title="0">daemonCmd.Process.Release()

                // Wait for daemon to be ready
                PrintInfo("Starting daemon...")
                for i := 0; i &lt; 10; i++ </span><span class="cov0" title="0">{
                        time.Sleep(200 * time.Millisecond)
                        if client.IsRunning() </span><span class="cov0" title="0">{
                                PrintSuccess("‚úì Daemon started")
                                PrintMuted("  ‚Ä¢ Auto-restart is now enabled")
                                PrintMuted("  ‚Ä¢ Processes will restart on crash")
                                PrintMuted("  ‚Ä¢ Use 'prox daemon stop' to stop the daemon")
                                return
                        }</span>
                }

                <span class="cov0" title="0">PrintWarning("Daemon started but not responding")</span>
        },
}

var daemonStopCmd = &amp;cobra.Command{
        Use:   "stop",
        Short: "Stop the prox daemon",
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                client, err := daemon.NewClient()
                if err != nil </span><span class="cov0" title="0">{
                        PrintError("Failed to create client: %v", err)
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">if !client.IsRunning() </span><span class="cov0" title="0">{
                        PrintMuted("Daemon not running")
                        return
                }</span>

                <span class="cov0" title="0">PrintInfo("Stopping daemon...")
                if err := client.Shutdown(); err != nil </span><span class="cov0" title="0">{
                        PrintError("Failed to stop daemon: %v", err)
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">PrintSuccess("‚úì Daemon stopped")
                PrintMuted("  ‚Ä¢ Auto-restart is now disabled")
                PrintMuted("  ‚Ä¢ Running processes will continue")</span>
        },
}

var daemonStatusCmd = &amp;cobra.Command{
        Use:   "status",
        Short: "Check daemon status",
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                client, err := daemon.NewClient()
                if err != nil </span><span class="cov0" title="0">{
                        PrintError("Failed to create client: %v", err)
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">if client.IsRunning() </span><span class="cov0" title="0">{
                        PrintSuccess("‚úì Daemon is running")

                        // Get process list
                        processes, err := client.List()
                        if err != nil </span><span class="cov0" title="0">{
                                PrintWarning("  Failed to get process list: %v", err)
                                return
                        }</span>

                        <span class="cov0" title="0">online := 0
                        for _, p := range processes </span><span class="cov0" title="0">{
                                if p.Status == process.StatusOnline </span><span class="cov0" title="0">{
                                        online++
                                }</span>
                        }

                        <span class="cov0" title="0">PrintMuted("  ‚Ä¢ Managing %d process(es)", len(processes))
                        PrintMuted("  ‚Ä¢ %d online", online)

                        // Show socket path
                        configDir, _ := process.ConfigDir()
                        sockPath := filepath.Join(configDir, "daemon.sock")
                        PrintMuted("  ‚Ä¢ Socket: %s", sockPath)</span>
                } else<span class="cov0" title="0"> {
                        PrintMuted("‚úó Daemon is not running")
                        PrintMuted("  ‚Ä¢ Start with: prox daemon start")
                        PrintMuted("  ‚Ä¢ Auto-restart is disabled")
                }</span>
        },
}

var daemonRunCmd = &amp;cobra.Command{
        Use:    "run",
        Short:  "Run the daemon (internal use)",
        Hidden: true,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                server, err := daemon.NewServer()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Failed to create server: %v\n", err)
                        os.Exit(1)
                }</span>

                // Redirect output to log file
                <span class="cov0" title="0">configDir, _ := process.ConfigDir()
                logPath := filepath.Join(configDir, "daemon.log")
                logFile, err := os.OpenFile(logPath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
                if err == nil </span><span class="cov0" title="0">{
                        os.Stdout = logFile
                        os.Stderr = logFile
                        defer logFile.Close()
                }</span>

                <span class="cov0" title="0">if err := server.Start(); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Daemon error: %v\n", err)
                        os.Exit(1)
                }</span>
        },
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(daemonCmd)
        daemonCmd.AddCommand(daemonStartCmd)
        daemonCmd.AddCommand(daemonStopCmd)
        daemonCmd.AddCommand(daemonStatusCmd)
        daemonCmd.AddCommand(daemonRunCmd)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package cmd

import (
        "os"

        "github.com/spf13/cobra"
)

var deleteCmd = &amp;cobra.Command{
        Use:     "delete &lt;name|id&gt;",
        Aliases: []string{"del", "rm"},
        Short:   "Delete a process",
        Long:    `Delete a process (stops it first if running)`,
        Args:    cobra.ExactArgs(1),
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                nameOrID := args[0]

                // Get shared manager
                mgr, _, err := getManager()
                if err != nil </span><span class="cov0" title="0">{
                        PrintError("Failed to initialize manager: %v", err)
                        os.Exit(1)
                }</span>

                // Delete process
                <span class="cov0" title="0">if err := mgr.Delete(nameOrID); err != nil </span><span class="cov0" title="0">{
                        PrintError("Failed to delete process: %v", err)
                        os.Exit(1)
                }</span>

                // Save state
                <span class="cov0" title="0">if err := saveState(); err != nil </span><span class="cov0" title="0">{
                        PrintWarning("Failed to save state: %v", err)
                }</span>

                <span class="cov0" title="0">PrintSuccess("Deleted '%s'", nameOrID)</span>
        },
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(deleteCmd)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package cmd

import (
        "github.com/craigderington/prox/internal/manager"
        "github.com/craigderington/prox/internal/process"
        "github.com/craigderington/prox/internal/storage"
)

// getManager returns the shared process manager and storage
func getManager() (*process.Manager, *storage.Storage, error) <span class="cov0" title="0">{
        return manager.Get()
}</span>

// saveState saves the current manager state
func saveState() error <span class="cov0" title="0">{
        return manager.Save()
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package cmd

import (
        "fmt"
        "os"

        "github.com/charmbracelet/lipgloss"
        "github.com/craigderington/prox/internal/config"
        "github.com/spf13/cobra"
)

var (
        initFile string
)

var initCmd = &amp;cobra.Command{
        Use:   "init",
        Short: "Initialize prox configuration from existing project files",
        Long: `Auto-discover services from Procfile, package.json, or docker-compose.yml
and create a prox.yml configuration file.

Examples:
  prox init                    # Auto-discover from current directory
  prox init -f ../Procfile     # Use specific Procfile
  prox init -f config/prod.Procfile`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                // Check if prox.yml already exists
                if _, err := os.Stat("prox.yml"); err == nil </span><span class="cov0" title="0">{
                        PrintError("prox.yml already exists. Delete it first or edit manually.")
                        os.Exit(1)
                }</span>

                // Auto-discover services
                <span class="cov0" title="0">PrintInfo("üîç Discovering services...")

                var cfg *config.Config
                var err error
                var source string

                if initFile != "" </span><span class="cov0" title="0">{
                        // Use specific file
                        source = initFile
                        PrintInfo("Using file: %s", initFile)
                        cfg, err = config.AutoDiscoverFromFile(initFile)
                }</span> else<span class="cov0" title="0"> {
                        // Auto-discover
                        cfg, err = config.AutoDiscover()
                        source = config.GetDiscoverySource()
                }</span>

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        PrintError("Failed to discover services: %v", err)
                        if initFile == "" </span><span class="cov0" title="0">{
                                PrintMuted("\nSupported files:")
                                PrintMuted("  ‚Ä¢ Procfile")
                                PrintMuted("  ‚Ä¢ package.json (npm scripts)")
                                PrintMuted("  ‚Ä¢ docker-compose.yml")
                                PrintMuted("\nOr use -f to specify a file")
                        }</span>
                        <span class="cov0" title="0">os.Exit(1)</span>
                }

                <span class="cov0" title="0">PrintSuccess("‚úì Found %d service(s) in %s", len(cfg.Services), source)

                // Show discovered services
                fmt.Println()
                PrintInfo("Discovered services:")
                for name, svc := range cfg.Services </span><span class="cov0" title="0">{
                        nameStyle := lipgloss.NewStyle().Foreground(colorSuccess).Render(name)
                        cmdStyle := lipgloss.NewStyle().Foreground(colorMuted).Render(svc.Command)
                        fmt.Printf("  ‚Ä¢ %s: %s\n", nameStyle, cmdStyle)
                }</span>

                // Save to prox.yml
                <span class="cov0" title="0">fmt.Println()
                PrintInfo("üìù Writing prox.yml...")
                if err := config.SaveConfig("prox.yml", cfg); err != nil </span><span class="cov0" title="0">{
                        PrintError("Failed to save config: %v", err)
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">PrintSuccess("‚úì Created prox.yml")
                fmt.Println()
                PrintMuted("Next steps:")
                PrintMuted("  1. Review and edit prox.yml if needed")
                PrintMuted("  2. Run 'prox start' to start all services")
                PrintMuted("  3. Run 'prox' to open the TUI dashboard")</span>
        },
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(initCmd)
        initCmd.Flags().StringVarP(&amp;initFile, "file", "f", "", "Specific config file to use (Procfile, package.json, docker-compose.yml)")
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package cmd

import (
        "fmt"
        "os"
        "strings"

        "github.com/charmbracelet/lipgloss"
        "github.com/charmbracelet/lipgloss/table"
        "github.com/craigderington/prox/internal/banner"
        "github.com/craigderington/prox/internal/process"
        "github.com/spf13/cobra"
)

var (
        showBanner bool
)

var listCmd = &amp;cobra.Command{
        Use:     "list",
        Aliases: []string{"ls", "status"},
        Short:   "List all processes",
        Long:    `Display a list of all managed processes with their status`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                // Get shared manager
                mgr, _, err := getManager()
                if err != nil </span><span class="cov0" title="0">{
                        PrintError("Failed to initialize manager: %v", err)
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">processes := mgr.List()

                // Show banner if requested or if no processes
                if showBanner || len(processes) == 0 </span><span class="cov0" title="0">{
                        fmt.Println(banner.Render())
                }</span>

                <span class="cov0" title="0">if len(processes) == 0 </span><span class="cov0" title="0">{
                        PrintMuted("No processes running. Get started:")
                        PrintMuted("  $ prox init              # Auto-discover services")
                        PrintMuted("  $ prox start app.js      # Start a single process")
                        return
                }</span>

                // Print compact header if banner not shown
                <span class="cov0" title="0">if !showBanner </span><span class="cov0" title="0">{
                        headerStyle := lipgloss.NewStyle().Foreground(colorInfo).Bold(true)
                        fmt.Println(headerStyle.Render("‚ö° prox - Process List"))
                        fmt.Println()
                }</span>

                // Collect metrics for all processes
                <span class="cov0" title="0">collector := process.NewMetricsCollector(mgr)
                metricsMap := collector.CollectAllMetrics()

                // Build table rows
                rows := [][]string{}
                for i, proc := range processes </span><span class="cov0" title="0">{
                        metrics := metricsMap[proc.ID]

                        uptime := "-"
                        if proc.Status == process.StatusOnline </span><span class="cov0" title="0">{
                                uptime = process.FormatDuration(proc.Uptime())
                        }</span>

                        // CPU and Memory
                        <span class="cov0" title="0">cpu := "-"
                        mem := "-"
                        if metrics != nil &amp;&amp; proc.Status == process.StatusOnline </span><span class="cov0" title="0">{
                                cpu = fmt.Sprintf("%.1f%%", metrics.CPU)
                                mem = process.FormatBytes(metrics.Memory)
                        }</span>

                        // Status with symbol
                        <span class="cov0" title="0">statusStr := string(proc.Status)
                        var statusWithSymbol string
                        switch proc.Status </span>{
                        case process.StatusOnline:<span class="cov0" title="0">
                                statusWithSymbol = "‚óè " + statusStr</span>
                        case process.StatusStopped:<span class="cov0" title="0">
                                statusWithSymbol = "‚óã " + statusStr</span>
                        case process.StatusErrored:<span class="cov0" title="0">
                                statusWithSymbol = "‚úó " + statusStr</span>
                        case process.StatusRestarting:<span class="cov0" title="0">
                                statusWithSymbol = "‚Üª " + statusStr</span>
                        default:<span class="cov0" title="0">
                                statusWithSymbol = statusStr</span>
                        }

                        <span class="cov0" title="0">rows = append(rows, []string{
                                fmt.Sprintf("%d", i),
                                proc.Name,
                                statusWithSymbol,
                                fmt.Sprintf("%d", proc.Restarts),
                                cpu,
                                mem,
                                uptime,
                                proc.Script,
                        })</span>
                }

                // Create beautiful lipgloss table
                <span class="cov0" title="0">colorBorder := lipgloss.Color("#45475A")
                tableHeaderStyle := lipgloss.NewStyle().
                        Foreground(colorInfo).
                        Bold(true).
                        Align(lipgloss.Left)

                t := table.New().
                        Border(lipgloss.RoundedBorder()).
                        BorderStyle(lipgloss.NewStyle().Foreground(colorBorder)).
                        StyleFunc(func(row, col int) lipgloss.Style </span><span class="cov0" title="0">{
                                // Header row
                                if row == 0 </span><span class="cov0" title="0">{
                                        return tableHeaderStyle
                                }</span>

                                // Bounds check for data rows
                                <span class="cov0" title="0">dataRow := row - 1
                                if dataRow &lt; 0 || dataRow &gt;= len(rows) </span><span class="cov0" title="0">{
                                        return mutedStyle
                                }</span>

                                // Status column (col 2) - apply color coding
                                <span class="cov0" title="0">if col == 2 </span><span class="cov0" title="0">{
                                        // Get the status text from the row
                                        statusText := rows[dataRow][col]
                                        // Check what status it contains
                                        if strings.HasPrefix(statusText, "‚óè") </span><span class="cov0" title="0">{ // online
                                                return successStyle
                                        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(statusText, "‚óã") </span><span class="cov0" title="0">{ // stopped
                                                return warningStyle // Orange for stopped
                                        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(statusText, "‚úó") </span><span class="cov0" title="0">{ // errored
                                                return errorStyle
                                        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(statusText, "‚Üª") </span><span class="cov0" title="0">{ // restarting
                                                return warningStyle
                                        }</span>
                                        <span class="cov0" title="0">return mutedStyle</span>
                                }

                                // CPU column - color by usage
                                <span class="cov0" title="0">if col == 4 </span><span class="cov0" title="0">{
                                        return lipgloss.NewStyle().Foreground(colorInfo)
                                }</span>

                                // Memory column - color by usage
                                <span class="cov0" title="0">if col == 5 </span><span class="cov0" title="0">{
                                        return lipgloss.NewStyle().Foreground(colorWarning)
                                }</span>

                                // Uptime column - muted
                                <span class="cov0" title="0">if col == 6 </span><span class="cov0" title="0">{
                                        return mutedStyle
                                }</span>

                                // Script column - muted
                                <span class="cov0" title="0">if col == 7 </span><span class="cov0" title="0">{
                                        return mutedStyle
                                }</span>

                                // Default
                                <span class="cov0" title="0">return mutedStyle</span>
                        }).
                        Headers("ID", "NAME", "STATUS", "‚Ü∫", "CPU", "MEMORY", "UPTIME", "SCRIPT").
                        Rows(rows...)

                // Add some padding around the table
                <span class="cov0" title="0">tableOutput := t.Render()
                paddedOutput := lipgloss.NewStyle().
                        Padding(0, 1).
                        Render(tableOutput)

                fmt.Println(paddedOutput)</span>
        },
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(listCmd)
        listCmd.Flags().BoolVarP(&amp;showBanner, "banner", "b", false, "Show prox banner and info")
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package cmd

import (
        "fmt"
        "os"
        "strings"

        "github.com/craigderington/prox/internal/logs"
        "github.com/spf13/cobra"
)

var (
        logsLines  int
        logsStream string
)

var logsCmd = &amp;cobra.Command{
        Use:   "logs &lt;name|id&gt;",
        Short: "View process logs",
        Long:  `View stdout and stderr logs for a process`,
        Args:  cobra.ExactArgs(1),
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                nameOrID := args[0]

                // Get shared manager
                mgr, storage, err := getManager()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "‚ö†Ô∏è  Failed to initialize manager: %v\n", err)
                        os.Exit(1)
                }</span>

                // Find process
                <span class="cov0" title="0">proc := mgr.Get(nameOrID)
                if proc == nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "‚ö†Ô∏è  Process not found: %s\n", nameOrID)
                        os.Exit(1)
                }</span>

                // Determine which log file(s) to read
                <span class="cov0" title="0">var logFiles []string
                var labels []string

                switch strings.ToLower(logsStream) </span>{
                case "out", "stdout":<span class="cov0" title="0">
                        logFiles = []string{storage.GetLogFile(proc.Name, "out")}
                        labels = []string{"STDOUT"}</span>
                case "err", "stderr":<span class="cov0" title="0">
                        logFiles = []string{storage.GetLogFile(proc.Name, "err")}
                        labels = []string{"STDERR"}</span>
                default:<span class="cov0" title="0"> // both
                        logFiles = []string{
                                storage.GetLogFile(proc.Name, "out"),
                                storage.GetLogFile(proc.Name, "err"),
                        }
                        labels = []string{"STDOUT", "STDERR"}</span>
                }

                // Read and display logs
                <span class="cov0" title="0">fmt.Printf("üìã Logs for '%s' (last %d lines)\n\n", proc.Name, logsLines)

                for i, logFile := range logFiles </span><span class="cov0" title="0">{
                        lines, err := logs.ReadTail(logFile, logsLines)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "‚ö†Ô∏è  Failed to read %s: %v\n", labels[i], err)
                                continue</span>
                        }

                        <span class="cov0" title="0">if len(lines) == 0 </span><span class="cov0" title="0">{
                                fmt.Printf("  [%s] No logs\n", labels[i])
                                continue</span>
                        }

                        <span class="cov0" title="0">for _, line := range lines </span><span class="cov0" title="0">{
                                fmt.Printf("  [%s] %s\n", labels[i], line)
                        }</span>
                }
        },
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(logsCmd)

        logsCmd.Flags().IntVarP(&amp;logsLines, "lines", "n", 50, "Number of lines to show")
        logsCmd.Flags().StringVarP(&amp;logsStream, "stream", "t", "both", "Stream to show (stdout, stderr, both)")
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package cmd

import (
        "fmt"

        "github.com/charmbracelet/lipgloss"
)

var (
        // CLI color palette
        colorSuccess = lipgloss.Color("#00FF87") // Green
        colorError   = lipgloss.Color("#FF5F87") // Red
        colorWarning = lipgloss.Color("#FFD700") // Yellow
        colorInfo    = lipgloss.Color("#00D9FF") // Cyan
        colorMuted   = lipgloss.Color("#6C7086") // Gray

        // CLI styles
        successStyle = lipgloss.NewStyle().Foreground(colorSuccess).Bold(true)
        errorStyle   = lipgloss.NewStyle().Foreground(colorError).Bold(true)
        warningStyle = lipgloss.NewStyle().Foreground(colorWarning).Bold(true)
        infoStyle    = lipgloss.NewStyle().Foreground(colorInfo).Bold(true)
        mutedStyle   = lipgloss.NewStyle().Foreground(colorMuted)
        labelStyle   = lipgloss.NewStyle().Foreground(colorMuted)
        valueStyle   = lipgloss.NewStyle().Foreground(colorInfo)
)

// PrintSuccess prints a success message with green checkmark
func PrintSuccess(format string, args ...interface{}) <span class="cov0" title="0">{
        msg := fmt.Sprintf(format, args...)
        fmt.Println(successStyle.Render("‚úì") + " " + successStyle.Render(msg))
}</span>

// PrintError prints an error message with red X
func PrintError(format string, args ...interface{}) <span class="cov0" title="0">{
        msg := fmt.Sprintf(format, args...)
        fmt.Println(errorStyle.Render("‚úó") + " " + errorStyle.Render(msg))
}</span>

// PrintWarning prints a warning message with yellow triangle
func PrintWarning(format string, args ...interface{}) <span class="cov0" title="0">{
        msg := fmt.Sprintf(format, args...)
        fmt.Println(warningStyle.Render("‚ö†") + " " + warningStyle.Render(msg))
}</span>

// PrintInfo prints an info message with cyan bullet
func PrintInfo(format string, args ...interface{}) <span class="cov0" title="0">{
        msg := fmt.Sprintf(format, args...)
        fmt.Println(infoStyle.Render("‚óè") + " " + msg)
}</span>

// PrintDetail prints a detail line with label and value
func PrintDetail(label, value string) <span class="cov0" title="0">{
        fmt.Printf("  %s %s\n", labelStyle.Render(label+":"), valueStyle.Render(value))
}</span>

// PrintMuted prints muted text
func PrintMuted(format string, args ...interface{}) <span class="cov0" title="0">{
        msg := fmt.Sprintf(format, args...)
        fmt.Println(mutedStyle.Render(msg))
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package cmd

import (
        "os"

        "github.com/spf13/cobra"
)

var restartCmd = &amp;cobra.Command{
        Use:   "restart &lt;name|id&gt;",
        Short: "Restart a process",
        Long:  `Restart a process by name or ID`,
        Args:  cobra.ExactArgs(1),
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                nameOrID := args[0]

                // Get shared manager
                mgr, _, err := getManager()
                if err != nil </span><span class="cov0" title="0">{
                        PrintError("Failed to initialize manager: %v", err)
                        os.Exit(1)
                }</span>

                // Restart process
                <span class="cov0" title="0">if err := mgr.Restart(nameOrID); err != nil </span><span class="cov0" title="0">{
                        PrintError("Failed to restart process: %v", err)
                        os.Exit(1)
                }</span>

                // Save state
                <span class="cov0" title="0">if err := saveState(); err != nil </span><span class="cov0" title="0">{
                        PrintWarning("Failed to save state: %v", err)
                }</span>

                <span class="cov0" title="0">PrintInfo("Restarted '%s'", nameOrID)</span>
        },
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(restartCmd)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package cmd

import (
        "fmt"
        "os"

        tea "github.com/charmbracelet/bubbletea"
        "github.com/craigderington/prox/internal/tui"
        "github.com/craigderington/prox/internal/version"
        "github.com/spf13/cobra"
)

var rootCmd = &amp;cobra.Command{
        Use:     "prox",
        Short:   "‚ö° Process manager TUI",
        Version: version.Version,
        Long: `                        -------------

                   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó
                   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïù
                   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ïî‚ïù
                   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó
                   ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ïó
                   ‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù

                               ‚ö° Process Manager ‚ö°

        prox is a modern process manager with a beautiful TUI
             for applications in any language.

                Start any application:
                $ prox start app.py

                Launch interactive TUI (default):
                $ prox

                Monitor processes in detail:
                $ prox monitor

                View process logs:
                $ prox logs my-app

                To go further checkout:
                https://github.com/craigderington/prox


                        -------------`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                // If no subcommand, launch TUI
                if err := launchTUI(); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error launching TUI: %v\n", err)
                        os.Exit(1)
                }</span>
        },
}

func Execute() <span class="cov0" title="0">{
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, err)
                os.Exit(1)
        }</span>
}

func init() {<span class="cov0" title="0">
        // Global flags can go here
}</span>

func launchTUI() error <span class="cov0" title="0">{
        // Get shared manager and storage
        mgr, store, err := getManager()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize manager: %w", err)
        }</span>

        // Create TUI model
        <span class="cov0" title="0">model := tui.NewModel(mgr, store)

        // Create Bubbletea program
        p := tea.NewProgram(model, tea.WithAltScreen())

        // Run the program
        if _, err := p.Run(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Save state on exit
        <span class="cov0" title="0">if err := saveState(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Warning: failed to save state: %v\n", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package cmd

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/charmbracelet/lipgloss"
        "github.com/charmbracelet/lipgloss/table"
        "github.com/craigderington/prox/internal/process"
        "github.com/spf13/cobra"
)

var (
        processName string
        processArgs []string
        processCwd  string
        interpreter string
)

var startCmd = &amp;cobra.Command{
        Use:   "start [script]",
        Short: "Start a process or all services from prox.yml",
        Long: `Start a new process or all services from prox.yml

Examples:
  prox start                           # Start all services from prox.yml
  prox start app.js                    # Start app.js with auto-detected name
  prox start app.js --name my-api      # Start with custom name "my-api"
  prox start server.py -n backend      # Start with short flag
  prox start app.js -i node            # Specify interpreter`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                // If no args, try to start from prox.yml
                if len(args) == 0 </span><span class="cov0" title="0">{
                        startAllCmd.Run(cmd, args)
                        return
                }</span>
                <span class="cov0" title="0">script := args[0]

                // Use script name as process name if not provided
                if processName == "" </span><span class="cov0" title="0">{
                        processName = filepath.Base(script)
                }</span>

                // Get remaining args
                <span class="cov0" title="0">if len(args) &gt; 1 </span><span class="cov0" title="0">{
                        processArgs = args[1:]
                }</span>

                // Detect interpreter if not specified
                <span class="cov0" title="0">if interpreter == "" </span><span class="cov0" title="0">{
                        interpreter = detectInterpreter(script)
                }</span>

                // Get current directory if not specified
                <span class="cov0" title="0">if processCwd == "" </span><span class="cov0" title="0">{
                        processCwd, _ = os.Getwd()
                }</span>

                // Create config
                <span class="cov0" title="0">config := process.ProcessConfig{
                        Name:        processName,
                        Script:      script,
                        Interpreter: interpreter,
                        Args:        processArgs,
                        Cwd:         processCwd,
                }

                // Get shared manager
                mgr, _, err := getManager()
                if err != nil </span><span class="cov0" title="0">{
                        PrintError("Failed to initialize manager: %v", err)
                        os.Exit(1)
                }</span>

                // Start process
                <span class="cov0" title="0">proc, err := mgr.Start(config)
                if err != nil </span><span class="cov0" title="0">{
                        PrintError("Failed to start process: %v", err)
                        os.Exit(1)
                }</span>

                // Save state
                <span class="cov0" title="0">if err := saveState(); err != nil </span><span class="cov0" title="0">{
                        PrintWarning("Failed to save state: %v", err)
                }</span>

                <span class="cov0" title="0">PrintSuccess("Started '%s' (PID %d)", proc.Name, proc.PID)
                PrintDetail("Script", proc.Script)
                if proc.Interpreter != "" </span><span class="cov0" title="0">{
                        PrintDetail("Interpreter", proc.Interpreter)
                }</span>
                <span class="cov0" title="0">PrintDetail("Status", string(proc.Status))

                fmt.Println()

                // Show all processes in a table
                processes := mgr.List()
                renderProcessTable(processes)

                fmt.Println()

                // Show helpful commands
                PrintInfo("Use 'prox' or 'prox monitor' to view in TUI")
                PrintMuted("     'prox list' to see all processes")
                PrintMuted("     'prox logs %s' to view logs", proc.Name)
                fmt.Println()
                PrintMuted("üí° Tip: Use --name to give your process a custom name")
                PrintMuted("     Example: prox start app.js --name my-api")</span>
        },
}

func detectInterpreter(script string) string <span class="cov0" title="0">{
        ext := filepath.Ext(script)
        switch ext </span>{
        case ".js":<span class="cov0" title="0">
                return "node"</span>
        case ".py":<span class="cov0" title="0">
                return "python"</span>
        case ".rb":<span class="cov0" title="0">
                return "ruby"</span>
        case ".sh":<span class="cov0" title="0">
                return "bash"</span>
        default:<span class="cov0" title="0">
                return ""</span> // Direct execution
        }
}

// renderProcessTable renders a colored table of processes
func renderProcessTable(processes []*process.Process) <span class="cov0" title="0">{
        if len(processes) == 0 </span><span class="cov0" title="0">{
                PrintMuted("No processes running")
                return
        }</span>

        // Build table rows
        <span class="cov0" title="0">rows := [][]string{}
        for i, proc := range processes </span><span class="cov0" title="0">{
                pid := "-"
                if proc.PID &gt; 0 </span><span class="cov0" title="0">{
                        pid = fmt.Sprintf("%d", proc.PID)
                }</span>

                // Status with symbol
                <span class="cov0" title="0">statusStr := string(proc.Status)
                var statusWithSymbol string
                switch proc.Status </span>{
                case process.StatusOnline:<span class="cov0" title="0">
                        statusWithSymbol = "‚óè " + statusStr</span>
                case process.StatusStopped:<span class="cov0" title="0">
                        statusWithSymbol = "‚óã " + statusStr</span>
                case process.StatusErrored:<span class="cov0" title="0">
                        statusWithSymbol = "‚úó " + statusStr</span>
                case process.StatusRestarting:<span class="cov0" title="0">
                        statusWithSymbol = "‚Üª " + statusStr</span>
                default:<span class="cov0" title="0">
                        statusWithSymbol = statusStr</span>
                }

                <span class="cov0" title="0">rows = append(rows, []string{
                        fmt.Sprintf("%d", i),
                        proc.Name,
                        statusWithSymbol,
                        pid,
                        fmt.Sprintf("%d", proc.Restarts),
                        proc.Script,
                })</span>
        }

        // Create beautiful lipgloss table
        <span class="cov0" title="0">colorBorder := lipgloss.Color("#45475A")
        tableHeaderStyle := lipgloss.NewStyle().
                Foreground(colorInfo).
                Bold(true).
                Align(lipgloss.Left).
                Padding(0, 1)

        t := table.New().
                Border(lipgloss.RoundedBorder()).
                BorderStyle(lipgloss.NewStyle().Foreground(colorBorder)).
                StyleFunc(func(row, col int) lipgloss.Style </span><span class="cov0" title="0">{
                        // Header row
                        if row == 0 </span><span class="cov0" title="0">{
                                return tableHeaderStyle
                        }</span>

                        // Bounds check for data rows
                        <span class="cov0" title="0">dataRow := row - 1
                        if dataRow &lt; 0 || dataRow &gt;= len(rows) </span><span class="cov0" title="0">{
                                return lipgloss.NewStyle()
                        }</span>

                        // ID column (col 0) - cyan
                        <span class="cov0" title="0">if col == 0 </span><span class="cov0" title="0">{
                                return lipgloss.NewStyle().Foreground(colorInfo).Padding(0, 1)
                        }</span>

                        // Status column (col 2) - apply color coding
                        <span class="cov0" title="0">if col == 2 </span><span class="cov0" title="0">{
                                statusText := rows[dataRow][col]
                                if strings.HasPrefix(statusText, "‚óè") </span><span class="cov0" title="0">{
                                        return successStyle
                                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(statusText, "‚óã") </span><span class="cov0" title="0">{
                                        return warningStyle // Orange for stopped
                                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(statusText, "‚úó") </span><span class="cov0" title="0">{
                                        return errorStyle
                                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(statusText, "‚Üª") </span><span class="cov0" title="0">{
                                        return warningStyle
                                }</span>
                                <span class="cov0" title="0">return lipgloss.NewStyle()</span>
                        }

                        // Script column (last column) - muted
                        <span class="cov0" title="0">if col == 5 </span><span class="cov0" title="0">{
                                return mutedStyle
                        }</span>

                        // Default style
                        <span class="cov0" title="0">return lipgloss.NewStyle().Padding(0, 1)</span>
                }).
                Headers("ID", "NAME", "STATUS", "PID", "RESTARTS", "SCRIPT").
                Rows(rows...)

        // Add some padding around the table
        <span class="cov0" title="0">tableOutput := t.Render()
        paddedOutput := lipgloss.NewStyle().
                Padding(0, 1).
                Render(tableOutput)

        fmt.Println(paddedOutput)</span>
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(startCmd)

        startCmd.Flags().StringVarP(&amp;processName, "name", "n", "", "Process name")
        startCmd.Flags().StringVarP(&amp;processCwd, "cwd", "c", "", "Working directory")
        startCmd.Flags().StringVarP(&amp;interpreter, "interpreter", "i", "", "Interpreter (node, python, etc.)")
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package cmd

import (
        "fmt"
        "os"
        "strings"
        "time"

        "github.com/craigderington/prox/internal/config"
        "github.com/craigderington/prox/internal/process"
        "github.com/spf13/cobra"
)

var startAllCmd = &amp;cobra.Command{
        Use:     "start-all",
        Aliases: []string{"up"},
        Short:   "Start all services from prox.yml",
        Long:    `Start all services defined in prox.yml configuration file`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                // Find config file
                configPath, err := config.FindConfigFile()
                if err != nil </span><span class="cov0" title="0">{
                        PrintError("No prox.yml found. Run 'prox init' first.")
                        os.Exit(1)
                }</span>

                // Load config
                <span class="cov0" title="0">PrintInfo("üìñ Loading config from %s", configPath)
                cfg, err := config.LoadConfig(configPath)
                if err != nil </span><span class="cov0" title="0">{
                        PrintError("Failed to load config: %v", err)
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">if len(cfg.Services) == 0 </span><span class="cov0" title="0">{
                        PrintWarning("No services defined in config")
                        os.Exit(0)
                }</span>

                // Get manager
                <span class="cov0" title="0">mgr, _, err := getManager()
                if err != nil </span><span class="cov0" title="0">{
                        PrintError("Failed to initialize manager: %v", err)
                        os.Exit(1)
                }</span>

                // Start services in dependency order
                <span class="cov0" title="0">PrintInfo("üöÄ Starting %d service(s)...\n", len(cfg.Services))

                started := make(map[string]bool)
                errors := []string{}

                // Helper to start a service and its dependencies
                var startService func(name string, svc config.ServiceConfig) error
                startService = func(name string, svc config.ServiceConfig) error </span><span class="cov0" title="0">{
                        if started[name] </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        // Start dependencies first
                        <span class="cov0" title="0">for _, dep := range svc.DependsOn </span><span class="cov0" title="0">{
                                if depSvc, ok := cfg.Services[dep]; ok </span><span class="cov0" title="0">{
                                        if err := startService(dep, depSvc); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        // Wait a bit for dependency to start
                                        <span class="cov0" title="0">time.Sleep(500 * time.Millisecond)</span>
                                }
                        }

                        // Parse command
                        <span class="cov0" title="0">parts := strings.Fields(svc.Command)
                        if len(parts) == 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("empty command")
                        }</span>

                        // Check if first part is a known interpreter
                        <span class="cov0" title="0">var script string
                        var args []string
                        var interp string

                        if svc.Interpreter != "" </span><span class="cov0" title="0">{
                                interp = svc.Interpreter
                        }</span>

                        // Check if command starts with an interpreter
                        <span class="cov0" title="0">knownInterpreters := map[string]bool{
                                "node": true, "python": true, "python3": true,
                                "ruby": true, "bash": true, "sh": true,
                                "go": true, "npm": true, "npx": true,
                        }

                        if len(parts) &gt; 1 &amp;&amp; knownInterpreters[parts[0]] </span><span class="cov0" title="0">{
                                // First part is interpreter, second is script
                                if interp == "" </span><span class="cov0" title="0">{
                                        interp = parts[0]
                                }</span>
                                <span class="cov0" title="0">script = parts[1]
                                if len(parts) &gt; 2 </span><span class="cov0" title="0">{
                                        args = parts[2:]
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // Direct execution
                                script = parts[0]
                                if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                                        args = parts[1:]
                                }</span>
                                <span class="cov0" title="0">if interp == "" </span><span class="cov0" title="0">{
                                        interp = detectInterpreter(script)
                                }</span>
                        }

                        // Set working directory
                        <span class="cov0" title="0">cwd := svc.Cwd
                        if cwd == "" </span><span class="cov0" title="0">{
                                cwd, _ = os.Getwd()
                        }</span>

                        // Convert restart policy
                        <span class="cov0" title="0">restartPolicy := process.RestartOnFailure
                        switch svc.Restart </span>{
                        case "always":<span class="cov0" title="0">
                                restartPolicy = process.RestartAlways</span>
                        case "never":<span class="cov0" title="0">
                                restartPolicy = process.RestartNever</span>
                        }

                        // Create process config
                        <span class="cov0" title="0">procConfig := process.ProcessConfig{
                                Name:        name,
                                Script:      script,
                                Interpreter: interp,
                                Args:        args,
                                Cwd:         cwd,
                                Env:         svc.Env,
                                Restart:     restartPolicy,
                                DependsOn:   svc.DependsOn,
                        }

                        // Start process
                        proc, err := mgr.Start(procConfig)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">started[name] = true
                        PrintSuccess("  ‚úì %s (PID %d)", name, proc.PID)
                        return nil</span>
                }

                // Start all services
                <span class="cov0" title="0">for name, svc := range cfg.Services </span><span class="cov0" title="0">{
                        if err := startService(name, svc); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, fmt.Sprintf("  ‚úó %s: %v", name, err))
                        }</span>
                }

                // Save state
                <span class="cov0" title="0">if err := saveState(); err != nil </span><span class="cov0" title="0">{
                        PrintWarning("Failed to save state: %v", err)
                }</span>

                // Print summary
                <span class="cov0" title="0">fmt.Println()
                if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                        PrintError("Failed to start some services:")
                        for _, e := range errors </span><span class="cov0" title="0">{
                                fmt.Println(e)
                        }</span>
                        <span class="cov0" title="0">fmt.Println()</span>
                }

                <span class="cov0" title="0">PrintSuccess("‚úì Started %d/%d services", len(started), len(cfg.Services))
                fmt.Println()
                PrintMuted("  ‚Ä¢ Run 'prox' to open TUI dashboard")
                PrintMuted("  ‚Ä¢ Run 'prox list' to see all processes")
                PrintMuted("  ‚Ä¢ Run 'prox logs &lt;name&gt;' to view logs")</span>
        },
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(startAllCmd)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package cmd

import (
        "os"

        "github.com/spf13/cobra"
)

var stopCmd = &amp;cobra.Command{
        Use:   "stop &lt;name|id&gt;",
        Short: "Stop a process",
        Long:  `Stop a running process by name or ID`,
        Args:  cobra.ExactArgs(1),
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                nameOrID := args[0]

                // Get shared manager
                mgr, _, err := getManager()
                if err != nil </span><span class="cov0" title="0">{
                        PrintError("Failed to initialize manager: %v", err)
                        os.Exit(1)
                }</span>

                // Stop process
                <span class="cov0" title="0">if err := mgr.Stop(nameOrID); err != nil </span><span class="cov0" title="0">{
                        PrintError("Failed to stop process: %v", err)
                        os.Exit(1)
                }</span>

                // Save state
                <span class="cov0" title="0">if err := saveState(); err != nil </span><span class="cov0" title="0">{
                        PrintWarning("Failed to save state: %v", err)
                }</span>

                <span class="cov0" title="0">PrintSuccess("Stopped '%s'", nameOrID)</span>
        },
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(stopCmd)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package banner

import (
        "github.com/charmbracelet/lipgloss"
)

const asciiArt = `
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó
‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïù
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ïî‚ïù
‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó
‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ïó
‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù
`

const tagline = "Process Manager for Modern Development"

const description = `
  prox is a lightweight TUI process manager with real-time metrics,
  auto-restart policies, and zero-config setup for any language.

  Quick Start:
  $ prox init              # Auto-discover from Procfile/package.json
  $ prox start             # Start all services
  $ prox                   # Open TUI dashboard with live metrics

  Features:
  ‚Ä¢ Beautiful TUI with CPU/Memory graphs
  ‚Ä¢ Auto-restart on crash (configurable policies)
  ‚Ä¢ Multi-language support (Node, Python, Go, Ruby, etc.)
  ‚Ä¢ Process dependencies and health checks
  ‚Ä¢ Zero-config with Procfile/package.json

  Learn more: https://github.com/yourusername/prox
`

// Render returns the formatted banner
func Render() string <span class="cov0" title="0">{
        colorPrimary := lipgloss.Color("#89b4fa")
        colorMuted := lipgloss.Color("#6c7086")
        colorAccent := lipgloss.Color("#f38ba8")

        logo := lipgloss.NewStyle().
                Foreground(colorPrimary).
                Bold(true).
                Render(asciiArt)

        tag := lipgloss.NewStyle().
                Foreground(colorAccent).
                Bold(true).
                Render(tagline)

        desc := lipgloss.NewStyle().
                Foreground(colorMuted).
                Render(description)

        divider := lipgloss.NewStyle().
                Foreground(colorMuted).
                Render("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ")

        return lipgloss.JoinVertical(
                lipgloss.Left,
                divider,
                "                   "+logo, // Center the logo
                "",
                "                    "+tag,
                desc,
                divider,
                "",
        )
}</span>

// RenderCompact returns just the logo without description
func RenderCompact() string <span class="cov0" title="0">{
        colorPrimary := lipgloss.Color("#89b4fa")
        colorAccent := lipgloss.Color("#f38ba8")

        logo := lipgloss.NewStyle().
                Foreground(colorPrimary).
                Bold(true).
                Render(asciiArt)

        tag := lipgloss.NewStyle().
                Foreground(colorAccent).
                Render("‚ö° " + tagline)

        return lipgloss.JoinVertical(
                lipgloss.Left,
                "                   "+logo, // Center the logo
                "",
                "                    "+tag,
                "",
        )
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package config

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "strings"
)

// AutoDiscover attempts to discover services from common configuration files
func AutoDiscover() (*Config, error) <span class="cov0" title="0">{
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Try discovery methods in order
        <span class="cov0" title="0">discoverers := []func(string) (*Config, error){
                discoverFromProcfile,
                discoverFromPackageJSON,
                discoverFromDockerCompose,
        }

        for _, discover := range discoverers </span><span class="cov0" title="0">{
                if config, err := discover(cwd); err == nil &amp;&amp; config != nil </span><span class="cov0" title="0">{
                        return config, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("no supported configuration files found")</span>
}

// AutoDiscoverFromFile discovers services from a specific file path
func AutoDiscoverFromFile(path string) (*Config, error) <span class="cov0" title="0">{
        // Check if file exists
        if _, err := os.Stat(path); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("file not found: %s", path)
        }</span>

        // Determine file type by name/extension
        <span class="cov0" title="0">filename := filepath.Base(path)
        dir := filepath.Dir(path)
        if dir == "." </span><span class="cov0" title="0">{
                dir, _ = os.Getwd()
        }</span>

        // Try different parsers based on filename
        <span class="cov0" title="0">if filename == "Procfile" || strings.HasPrefix(filename, "Procfile.") </span><span class="cov0" title="0">{
                return parseSpecificProcfile(path, dir)
        }</span> else<span class="cov0" title="0"> if filename == "package.json" </span><span class="cov0" title="0">{
                return discoverFromPackageJSON(dir)
        }</span> else<span class="cov0" title="0"> if strings.Contains(filename, "docker-compose") </span><span class="cov0" title="0">{
                return parseDockerCompose(path, dir)
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("unsupported file type: %s (expected Procfile, package.json, or docker-compose.yml)", filename)</span>
}

// parseSpecificProcfile reads a Procfile from a specific path
func parseSpecificProcfile(path, baseDir string) (*Config, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">config := &amp;Config{
                Services: make(map[string]ServiceConfig),
        }

        lines := strings.Split(string(data), "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">parts := strings.SplitN(line, ":", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">name := strings.TrimSpace(parts[0])
                command := strings.TrimSpace(parts[1])

                config.Services[name] = ServiceConfig{
                        Command:   command,
                        Restart:   "on-failure",
                        Cwd:       baseDir,
                        Instances: 1,
                }</span>
        }

        <span class="cov0" title="0">if len(config.Services) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no services found in Procfile")
        }</span>

        <span class="cov0" title="0">return config, nil</span>
}

// discoverFromProcfile reads Procfile format
func discoverFromProcfile(dir string) (*Config, error) <span class="cov0" title="0">{
        path := filepath.Join(dir, "Procfile")
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">config := &amp;Config{
                Services: make(map[string]ServiceConfig),
        }

        lines := strings.Split(string(data), "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">parts := strings.SplitN(line, ":", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">name := strings.TrimSpace(parts[0])
                command := strings.TrimSpace(parts[1])

                config.Services[name] = ServiceConfig{
                        Command:  command,
                        Restart:  "on-failure",
                        Cwd:      dir,
                        Instances: 1,
                }</span>
        }

        <span class="cov0" title="0">if len(config.Services) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no services found in Procfile")
        }</span>

        <span class="cov0" title="0">return config, nil</span>
}

// discoverFromPackageJSON reads package.json scripts
func discoverFromPackageJSON(dir string) (*Config, error) <span class="cov0" title="0">{
        path := filepath.Join(dir, "package.json")
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var pkg struct {
                Scripts map[string]string `json:"scripts"`
        }

        if err := json.Unmarshal(data, &amp;pkg); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(pkg.Scripts) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no scripts found in package.json")
        }</span>

        <span class="cov0" title="0">config := &amp;Config{
                Services: make(map[string]ServiceConfig),
        }

        // Look for common development scripts
        devScripts := []string{"dev", "start", "serve"}
        for _, scriptName := range devScripts </span><span class="cov0" title="0">{
                if _, ok := pkg.Scripts[scriptName]; ok </span><span class="cov0" title="0">{
                        config.Services[scriptName] = ServiceConfig{
                                Command:   "npm run " + scriptName,
                                Restart:   "on-failure",
                                Cwd:       dir,
                                Instances: 1,
                        }
                }</span>
        }

        <span class="cov0" title="0">if len(config.Services) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no dev scripts found in package.json")
        }</span>

        <span class="cov0" title="0">return config, nil</span>
}

// discoverFromDockerCompose reads docker-compose.yml
func discoverFromDockerCompose(dir string) (*Config, error) <span class="cov0" title="0">{
        paths := []string{
                filepath.Join(dir, "docker-compose.yml"),
                filepath.Join(dir, "docker-compose.yaml"),
        }

        for _, path := range paths </span><span class="cov0" title="0">{
                if _, err := os.Stat(path); err == nil </span><span class="cov0" title="0">{
                        return parseDockerCompose(path, dir)
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("no docker-compose file found")</span>
}

// parseDockerCompose parses docker-compose.yml (simplified)
func parseDockerCompose(path, dir string) (*Config, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var compose struct {
                Services map[string]struct {
                        Command   string   `yaml:"command"`
                        DependsOn []string `yaml:"depends_on"`
                } `yaml:"services"`
        }

        if err := json.Unmarshal(data, &amp;compose); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">config := &amp;Config{
                Services: make(map[string]ServiceConfig),
        }

        for name, svc := range compose.Services </span><span class="cov0" title="0">{
                if svc.Command != "" </span><span class="cov0" title="0">{
                        config.Services[name] = ServiceConfig{
                                Command:   svc.Command,
                                Restart:   "on-failure",
                                Cwd:       dir,
                                Instances: 1,
                                DependsOn: svc.DependsOn,
                        }
                }</span>
        }

        <span class="cov0" title="0">if len(config.Services) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no runnable services found in docker-compose")
        }</span>

        <span class="cov0" title="0">return config, nil</span>
}

// GetDiscoverySource returns what file was used for discovery
func GetDiscoverySource() string <span class="cov0" title="0">{
        cwd, _ := os.Getwd()

        if _, err := os.Stat(filepath.Join(cwd, "Procfile")); err == nil </span><span class="cov0" title="0">{
                return "Procfile"
        }</span>
        <span class="cov0" title="0">if _, err := os.Stat(filepath.Join(cwd, "package.json")); err == nil </span><span class="cov0" title="0">{
                return "package.json"
        }</span>
        <span class="cov0" title="0">if _, err := os.Stat(filepath.Join(cwd, "docker-compose.yml")); err == nil </span><span class="cov0" title="0">{
                return "docker-compose.yml"
        }</span>

        <span class="cov0" title="0">return "unknown"</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package config

import (
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "strings"

        yaml "gopkg.in/yaml.v3"
)

// Config represents the prox.yml configuration file structure.
// It contains all the services to be managed by prox.
type Config struct {
        // Services is a map of service names to their configurations
        Services map[string]ServiceConfig `yaml:"services"`
}

// ServiceConfig represents a single service configuration.
// Each service defines how a process should be started and managed.
type ServiceConfig struct {
        // Command is the full command to execute (alternative to Script+Interpreter)
        Command string `yaml:"command,omitempty"`
        // Script is the script file to execute
        Script string `yaml:"script,omitempty"`
        // Interpreter is the interpreter to use (node, python, ruby, etc.)
        Interpreter string `yaml:"interpreter,omitempty"`
        // Args are additional command line arguments
        Args []string `yaml:"args,omitempty"`
        // Cwd is the working directory for the process
        Cwd string `yaml:"cwd,omitempty"`
        // Env is environment variables to set
        Env map[string]string `yaml:"env,omitempty"`
        // Instances is the number of instances to run (default: 1)
        Instances int `yaml:"instances,omitempty"`
        // Restart defines when to restart the process ("always", "on-failure", "never")
        Restart string `yaml:"restart,omitempty"`
        // Watch is a list of files/directories to watch for changes
        Watch []string `yaml:"watch,omitempty"`
        // DependsOn is a list of services this service depends on
        DependsOn []string `yaml:"depends_on,omitempty"`
        // HealthCheck defines how to check if the service is healthy
        HealthCheck *HealthCheck `yaml:"healthcheck,omitempty"`
}

// HealthCheck defines health check configuration for a service.
type HealthCheck struct {
        // HTTPGet is the HTTP endpoint to check
        HTTPGet string `yaml:"http_get,omitempty"`
        // Interval is how often to perform the health check
        Interval string `yaml:"interval,omitempty"`
        // Timeout is how long to wait for the health check to complete
        Timeout string `yaml:"timeout,omitempty"`
}

// LoadConfig loads and validates configuration from a YAML file.
// It parses the prox.yml file, validates the configuration, and applies defaults.
// Returns an error if the file cannot be read, parsed, or if validation fails.
func LoadConfig(path string) (*Config, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        <span class="cov8" title="1">var config Config
        if err := yaml.Unmarshal(data, &amp;config); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse YAML: %w", err)
        }</span>

        // Validate configuration before setting defaults
        <span class="cov8" title="1">if err := ValidateConfig(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("configuration validation failed: %w", err)
        }</span>

        // Set defaults after validation
        <span class="cov8" title="1">for name, svc := range config.Services </span><span class="cov8" title="1">{
                if svc.Instances == 0 </span><span class="cov8" title="1">{
                        svc.Instances = 1
                }</span>
                <span class="cov8" title="1">if svc.Restart == "" </span><span class="cov8" title="1">{
                        svc.Restart = "on-failure"
                }</span>
                <span class="cov8" title="1">config.Services[name] = svc</span>
        }

        <span class="cov8" title="1">return &amp;config, nil</span>
}

// ValidateConfig performs comprehensive validation of the configuration.
// It checks for required fields, valid values, dependency cycles, and other
// configuration constraints. Returns nil if the configuration is valid.
func ValidateConfig(config *Config) error <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("config cannot be nil")
        }</span>

        <span class="cov8" title="1">if len(config.Services) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("no services defined in configuration")
        }</span>

        // Track service names for uniqueness and dependency validation
        <span class="cov8" title="1">serviceNames := make(map[string]bool)
        dependencyGraph := make(map[string][]string)

        for name, service := range config.Services </span><span class="cov8" title="1">{
                // Check for duplicate service names
                if serviceNames[name] </span><span class="cov0" title="0">{
                        return fmt.Errorf("duplicate service name: %s", name)
                }</span>
                <span class="cov8" title="1">serviceNames[name] = true

                // Validate service name format
                if err := validateServiceName(name); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid service name '%s': %w", name, err)
                }</span>

                // Validate required fields
                <span class="cov8" title="1">if service.Script == "" &amp;&amp; service.Command == "" </span><span class="cov8" title="1">{
                        return fmt.Errorf("service '%s' must have either 'script' or 'command' defined", name)
                }</span>

                // Validate interpreter
                <span class="cov8" title="1">if service.Interpreter != "" </span><span class="cov8" title="1">{
                        if err := validateInterpreter(service.Interpreter); err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("service '%s' has invalid interpreter '%s': %w", name, service.Interpreter, err)
                        }</span>
                }

                // Validate restart policy
                <span class="cov8" title="1">if err := validateRestartPolicy(service.Restart); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("service '%s' has invalid restart policy '%s': %w", name, service.Restart, err)
                }</span>

                // Validate instances (only if explicitly set, since defaults will be applied later)
                <span class="cov8" title="1">if service.Instances != 0 &amp;&amp; service.Instances &lt; 1 </span><span class="cov8" title="1">{
                        return fmt.Errorf("service '%s' must have at least 1 instance (got %d)", name, service.Instances)
                }</span>

                // Validate environment variables
                <span class="cov8" title="1">for key, value := range service.Env </span><span class="cov8" title="1">{
                        if err := validateEnvVar(key, value); err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("service '%s' has invalid environment variable %s=%s: %w", name, key, value, err)
                        }</span>
                }

                // Build dependency graph
                <span class="cov8" title="1">dependencyGraph[name] = service.DependsOn</span>
        }

        // Check for dependency cycles
        <span class="cov8" title="1">if err := detectDependencyCycles(dependencyGraph); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("dependency cycle detected: %w", err)
        }</span>

        // Validate that all dependencies exist
        <span class="cov8" title="1">for serviceName, deps := range dependencyGraph </span><span class="cov8" title="1">{
                for _, dep := range deps </span><span class="cov8" title="1">{
                        if !serviceNames[dep] </span><span class="cov8" title="1">{
                                return fmt.Errorf("service '%s' depends on unknown service '%s'", serviceName, dep)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// validateServiceName validates that a service name follows proper conventions
func validateServiceName(name string) error <span class="cov8" title="1">{
        if name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("service name cannot be empty")
        }</span>

        <span class="cov8" title="1">if len(name) &gt; 64 </span><span class="cov0" title="0">{
                return fmt.Errorf("service name too long (max 64 characters)")
        }</span>

        // Service names should be valid identifiers (alphanumeric, dash, underscore)
        <span class="cov8" title="1">validName := regexp.MustCompile(`^[a-zA-Z0-9_-]+$`)
        if !validName.MatchString(name) </span><span class="cov8" title="1">{
                return fmt.Errorf("service name must contain only letters, numbers, dashes, and underscores")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateInterpreter validates that an interpreter is supported
func validateInterpreter(interpreter string) error <span class="cov8" title="1">{
        supported := map[string]bool{
                "node":    true,
                "nodejs":  true,
                "python":  true,
                "python2": true,
                "python3": true,
                "ruby":    true,
                "perl":    true,
                "php":     true,
                "bash":    true,
                "sh":      true,
                "zsh":     true,
                "fish":    true,
                "go":      true,
                "rust":    true,
                "java":    true,
        }

        if !supported[strings.ToLower(interpreter)] </span><span class="cov8" title="1">{
                return fmt.Errorf("unsupported interpreter (supported: node, python, ruby, perl, php, bash, sh, zsh, fish, go, rust, java)")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateRestartPolicy validates restart policy values
func validateRestartPolicy(policy string) error <span class="cov8" title="1">{
        validPolicies := map[string]bool{
                "always":     true,
                "on-failure": true,
                "never":      true,
                "":           true, // Empty is allowed (will be set to default)
        }

        if !validPolicies[strings.ToLower(policy)] </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid restart policy (must be: always, on-failure, never)")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateEnvVar validates environment variable format
func validateEnvVar(key, value string) error <span class="cov8" title="1">{
        if key == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("environment variable key cannot be empty")
        }</span>

        // Environment variable names should be valid
        <span class="cov8" title="1">validKey := regexp.MustCompile(`^[A-Z_][A-Z0-9_]*$`)
        if !validKey.MatchString(key) </span><span class="cov8" title="1">{
                return fmt.Errorf("environment variable key must start with letter/underscore and contain only uppercase letters, numbers, and underscores")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// detectDependencyCycles detects circular dependencies in the service dependency graph
func detectDependencyCycles(graph map[string][]string) error <span class="cov8" title="1">{
        // Simple cycle detection using DFS
        visited := make(map[string]bool)
        recursionStack := make(map[string]bool)

        var dfs func(string) error
        dfs = func(service string) error </span><span class="cov8" title="1">{
                visited[service] = true
                recursionStack[service] = true

                for _, dep := range graph[service] </span><span class="cov8" title="1">{
                        if !visited[dep] </span><span class="cov8" title="1">{
                                if err := dfs(dep); err != nil </span><span class="cov8" title="1">{
                                        return err
                                }</span>
                        } else<span class="cov8" title="1"> if recursionStack[dep] </span><span class="cov8" title="1">{
                                return fmt.Errorf("cycle involving %s -&gt; %s", service, dep)
                        }</span>
                }

                <span class="cov8" title="1">recursionStack[service] = false
                return nil</span>
        }

        <span class="cov8" title="1">for service := range graph </span><span class="cov8" title="1">{
                if !visited[service] </span><span class="cov8" title="1">{
                        if err := dfs(service); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// FindConfigFile searches for a prox configuration file.
// It looks for prox.yml, prox.yaml, or .prox.yml in the current directory
// and parent directories, returning the path to the first one found.
// Returns an error if no configuration file is found.
func FindConfigFile() (string, error) <span class="cov8" title="1">{
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Try common config file names
        <span class="cov8" title="1">names := []string{"prox.yml", "prox.yaml", ".prox.yml"}

        dir := cwd
        for </span><span class="cov8" title="1">{
                for _, name := range names </span><span class="cov8" title="1">{
                        path := filepath.Join(dir, name)
                        if _, err := os.Stat(path); err == nil </span><span class="cov8" title="1">{
                                return path, nil
                        }</span>
                }

                <span class="cov8" title="1">parent := filepath.Dir(dir)
                if parent == dir </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">dir = parent</span>
        }

        <span class="cov8" title="1">return "", fmt.Errorf("no config file found (looked for prox.yml)")</span>
}

// SaveConfig writes configuration to a YAML file.
// It serializes the config struct to YAML format and writes it to the specified path.
func SaveConfig(path string, config *Config) error <span class="cov8" title="1">{
        data, err := yaml.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal YAML: %w", err)
        }</span>

        <span class="cov8" title="1">if err := os.WriteFile(path, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config file: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package daemon

import (
        "bufio"
        "encoding/json"
        "fmt"
        "net"
        "path/filepath"
        "time"

        "github.com/craigderington/prox/internal/process"
)

// Client is a daemon client
type Client struct {
        sockPath string
}

// NewClient creates a new daemon client
func NewClient() (*Client, error) <span class="cov0" title="0">{
        configDir, err := process.ConfigDir()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">sockPath := filepath.Join(configDir, "daemon.sock")

        return &amp;Client{
                sockPath: sockPath,
        }, nil</span>
}

// IsRunning checks if the daemon is running
func (c *Client) IsRunning() bool <span class="cov0" title="0">{
        conn, err := c.connect()
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">conn.Close()
        return true</span>
}

// Ping pings the daemon
func (c *Client) Ping() error <span class="cov0" title="0">{
        _, err := c.request(MethodPing, nil)
        return err
}</span>

// Start starts a process
func (c *Client) Start(config process.ProcessConfig) (*process.Process, error) <span class="cov0" title="0">{
        params := StartParams{Config: config}
        paramsData, _ := json.Marshal(params)

        respData, err := c.request(MethodStart, paramsData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var resp StartResponse
        if err := json.Unmarshal(respData, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return resp.Process, nil</span>
}

// Stop stops a process
func (c *Client) Stop(nameOrID string) error <span class="cov0" title="0">{
        params := StopParams{NameOrID: nameOrID}
        paramsData, _ := json.Marshal(params)

        _, err := c.request(MethodStop, paramsData)
        return err
}</span>

// Restart restarts a process
func (c *Client) Restart(nameOrID string) error <span class="cov0" title="0">{
        params := RestartParams{NameOrID: nameOrID}
        paramsData, _ := json.Marshal(params)

        _, err := c.request(MethodRestart, paramsData)
        return err
}</span>

// Delete deletes a process
func (c *Client) Delete(nameOrID string) error <span class="cov0" title="0">{
        params := DeleteParams{NameOrID: nameOrID}
        paramsData, _ := json.Marshal(params)

        _, err := c.request(MethodDelete, paramsData)
        return err
}</span>

// List lists all processes
func (c *Client) List() ([]*process.Process, error) <span class="cov0" title="0">{
        respData, err := c.request(MethodList, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var resp ListResponse
        if err := json.Unmarshal(respData, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return resp.Processes, nil</span>
}

// Get gets a process
func (c *Client) Get(nameOrID string) (*process.Process, error) <span class="cov0" title="0">{
        params := GetParams{NameOrID: nameOrID}
        paramsData, _ := json.Marshal(params)

        respData, err := c.request(MethodGet, paramsData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var resp GetResponse
        if err := json.Unmarshal(respData, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return resp.Process, nil</span>
}

// Shutdown shuts down the daemon
func (c *Client) Shutdown() error <span class="cov0" title="0">{
        _, err := c.request(MethodShutdown, nil)
        return err
}</span>

// request sends an RPC request and returns the response data
func (c *Client) request(method string, params json.RawMessage) (json.RawMessage, error) <span class="cov0" title="0">{
        conn, err := c.connect()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to daemon: %w", err)
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        // Create request
        req := RPCRequest{
                Method: method,
                Params: params,
        }

        // Send request
        reqData, _ := json.Marshal(req)
        writer := bufio.NewWriter(conn)
        writer.Write(reqData)
        writer.WriteByte('\n')
        writer.Flush()

        // Read response
        reader := bufio.NewReader(conn)
        respLine, err := reader.ReadBytes('\n')
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">var resp RPCResponse
        if err := json.Unmarshal(respLine, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid response: %w", err)
        }</span>

        <span class="cov0" title="0">if !resp.Success </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("daemon error: %s", resp.Error)
        }</span>

        <span class="cov0" title="0">return resp.Data, nil</span>
}

// connect establishes a connection to the daemon
func (c *Client) connect() (net.Conn, error) <span class="cov0" title="0">{
        return net.DialTimeout("unix", c.sockPath, 2*time.Second)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package daemon

import (
        "bufio"
        "encoding/json"
        "fmt"
        "net"
        "os"
        "path/filepath"
        "sync"

        "github.com/craigderington/prox/internal/process"
        "github.com/craigderington/prox/internal/storage"
)

// Server is the daemon server
type Server struct {
        manager  *process.Manager
        storage  *storage.Storage
        listener net.Listener
        sockPath string
        mu       sync.RWMutex
        running  bool
}

// NewServer creates a new daemon server
func NewServer() (*Server, error) <span class="cov0" title="0">{
        // Get socket path
        configDir, err := process.ConfigDir()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">sockPath := filepath.Join(configDir, "daemon.sock")

        // Create manager and storage
        mgr := process.NewManager()
        st, err := storage.New()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">mgr.SetStorage(st)

        return &amp;Server{
                manager:  mgr,
                storage:  st,
                sockPath: sockPath,
        }, nil</span>
}

// Start starts the daemon server
func (s *Server) Start() error <span class="cov0" title="0">{
        s.mu.Lock()
        if s.running </span><span class="cov0" title="0">{
                s.mu.Unlock()
                return fmt.Errorf("daemon already running")
        }</span>
        <span class="cov0" title="0">s.mu.Unlock()

        // Remove old socket if exists
        os.Remove(s.sockPath)

        // Create listener
        listener, err := net.Listen("unix", s.sockPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create socket: %w", err)
        }</span>

        <span class="cov0" title="0">s.listener = listener
        s.mu.Lock()
        s.running = true
        s.mu.Unlock()

        fmt.Printf("[daemon] Started on %s\n", s.sockPath)

        // Load saved processes
        if err := s.loadState(); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("[daemon] Warning: failed to load state: %v\n", err)
        }</span>

        // Accept connections
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                conn, err := listener.Accept()
                if err != nil </span><span class="cov0" title="0">{
                        s.mu.RLock()
                        running := s.running
                        s.mu.RUnlock()
                        if !running </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">fmt.Printf("[daemon] Accept error: %v\n", err)
                        continue</span>
                }

                <span class="cov0" title="0">go s.handleConnection(conn)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Stop stops the daemon server
func (s *Server) Stop() error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if !s.running </span><span class="cov0" title="0">{
                return fmt.Errorf("daemon not running")
        }</span>

        <span class="cov0" title="0">s.running = false

        // Save state
        if err := s.saveState(); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("[daemon] Warning: failed to save state: %v\n", err)
        }</span>

        // Stop all processes
        <span class="cov0" title="0">s.manager.StopAll()

        // Close listener
        if s.listener != nil </span><span class="cov0" title="0">{
                s.listener.Close()
        }</span>

        // Remove socket
        <span class="cov0" title="0">os.Remove(s.sockPath)

        return nil</span>
}

// handleConnection handles a client connection
func (s *Server) handleConnection(conn net.Conn) <span class="cov0" title="0">{
        defer conn.Close()

        reader := bufio.NewReader(conn)
        writer := bufio.NewWriter(conn)

        // Read request
        line, err := reader.ReadBytes('\n')
        if err != nil </span><span class="cov0" title="0">{
                s.sendError(writer, fmt.Sprintf("failed to read request: %v", err))
                return
        }</span>

        <span class="cov0" title="0">var req RPCRequest
        if err := json.Unmarshal(line, &amp;req); err != nil </span><span class="cov0" title="0">{
                s.sendError(writer, fmt.Sprintf("invalid JSON: %v", err))
                return
        }</span>

        // Handle request
        <span class="cov0" title="0">s.handleRequest(writer, &amp;req)</span>
}

// handleRequest handles an RPC request
func (s *Server) handleRequest(writer *bufio.Writer, req *RPCRequest) <span class="cov0" title="0">{
        switch req.Method </span>{
        case MethodPing:<span class="cov0" title="0">
                s.sendSuccess(writer, nil)</span>

        case MethodStart:<span class="cov0" title="0">
                var params StartParams
                if err := json.Unmarshal(req.Params, &amp;params); err != nil </span><span class="cov0" title="0">{
                        s.sendError(writer, fmt.Sprintf("invalid params: %v", err))
                        return
                }</span>
                <span class="cov0" title="0">proc, err := s.manager.Start(params.Config)
                if err != nil </span><span class="cov0" title="0">{
                        s.sendError(writer, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">s.saveState()
                data, _ := json.Marshal(StartResponse{Process: proc})
                s.sendSuccess(writer, data)</span>

        case MethodStop:<span class="cov0" title="0">
                var params StopParams
                if err := json.Unmarshal(req.Params, &amp;params); err != nil </span><span class="cov0" title="0">{
                        s.sendError(writer, fmt.Sprintf("invalid params: %v", err))
                        return
                }</span>
                <span class="cov0" title="0">if err := s.manager.Stop(params.NameOrID); err != nil </span><span class="cov0" title="0">{
                        s.sendError(writer, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">s.saveState()
                s.sendSuccess(writer, nil)</span>

        case MethodRestart:<span class="cov0" title="0">
                var params RestartParams
                if err := json.Unmarshal(req.Params, &amp;params); err != nil </span><span class="cov0" title="0">{
                        s.sendError(writer, fmt.Sprintf("invalid params: %v", err))
                        return
                }</span>
                <span class="cov0" title="0">if err := s.manager.Restart(params.NameOrID); err != nil </span><span class="cov0" title="0">{
                        s.sendError(writer, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">s.saveState()
                s.sendSuccess(writer, nil)</span>

        case MethodDelete:<span class="cov0" title="0">
                var params DeleteParams
                if err := json.Unmarshal(req.Params, &amp;params); err != nil </span><span class="cov0" title="0">{
                        s.sendError(writer, fmt.Sprintf("invalid params: %v", err))
                        return
                }</span>
                <span class="cov0" title="0">if err := s.manager.Delete(params.NameOrID); err != nil </span><span class="cov0" title="0">{
                        s.sendError(writer, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">s.saveState()
                s.sendSuccess(writer, nil)</span>

        case MethodList:<span class="cov0" title="0">
                processes := s.manager.List()
                data, _ := json.Marshal(ListResponse{Processes: processes})
                s.sendSuccess(writer, data)</span>

        case MethodGet:<span class="cov0" title="0">
                var params GetParams
                if err := json.Unmarshal(req.Params, &amp;params); err != nil </span><span class="cov0" title="0">{
                        s.sendError(writer, fmt.Sprintf("invalid params: %v", err))
                        return
                }</span>
                <span class="cov0" title="0">proc := s.manager.Get(params.NameOrID)
                if proc == nil </span><span class="cov0" title="0">{
                        s.sendError(writer, "process not found")
                        return
                }</span>
                <span class="cov0" title="0">data, _ := json.Marshal(GetResponse{Process: proc})
                s.sendSuccess(writer, data)</span>

        case MethodShutdown:<span class="cov0" title="0">
                s.sendSuccess(writer, nil)
                go s.Stop()</span>

        default:<span class="cov0" title="0">
                s.sendError(writer, fmt.Sprintf("unknown method: %s", req.Method))</span>
        }
}

// sendSuccess sends a success response
func (s *Server) sendSuccess(writer *bufio.Writer, data json.RawMessage) <span class="cov0" title="0">{
        resp := RPCResponse{
                Success: true,
                Data:    data,
        }
        s.sendResponse(writer, &amp;resp)
}</span>

// sendError sends an error response
func (s *Server) sendError(writer *bufio.Writer, errMsg string) <span class="cov0" title="0">{
        resp := RPCResponse{
                Success: false,
                Error:   errMsg,
        }
        s.sendResponse(writer, &amp;resp)
}</span>

// sendResponse sends an RPC response
func (s *Server) sendResponse(writer *bufio.Writer, resp *RPCResponse) <span class="cov0" title="0">{
        data, _ := json.Marshal(resp)
        writer.Write(data)
        writer.WriteByte('\n')
        writer.Flush()
}</span>

// saveState saves process state
func (s *Server) saveState() error <span class="cov0" title="0">{
        return process.SaveState(s.manager, s.storage)
}</span>

// loadState loads process state
func (s *Server) loadState() error <span class="cov0" title="0">{
        return process.LoadState(s.manager, s.storage)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package logs

import (
        "bufio"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "sync"
        "time"
)

// LogConfig represents log configuration for a process
type LogConfig struct {
        OutFile  string // stdout log file
        ErrFile  string // stderr log file
        MaxSize  int64  // max size in bytes before rotation
        MaxFiles int    // max number of rotated files to keep
}

// DefaultLogConfig returns default log configuration
func DefaultLogConfig(logDir, processName string) LogConfig <span class="cov0" title="0">{
        return LogConfig{
                OutFile:  filepath.Join(logDir, fmt.Sprintf("%s-out.log", processName)),
                ErrFile:  filepath.Join(logDir, fmt.Sprintf("%s-err.log", processName)),
                MaxSize:  10 * 1024 * 1024, // 10MB
                MaxFiles: 5,
        }
}</span>

// Logger handles logging for a process
type Logger struct {
        config LogConfig
        outMu  sync.Mutex
        errMu  sync.Mutex
}

// NewLogger creates a new logger
func NewLogger(config LogConfig) *Logger <span class="cov0" title="0">{
        return &amp;Logger{
                config: config,
        }
}</span>

// StreamLogs streams stdout and stderr from readers to log files
// This function returns immediately and streams in the background
func (l *Logger) StreamLogs(stdout, stderr io.Reader, stopCh &lt;-chan struct{}) <span class="cov0" title="0">{
        // Stream stdout
        go func() </span><span class="cov0" title="0">{
                if err := l.streamToFile(stdout, l.config.OutFile, "stdout", stopCh); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "[prox] Error streaming stdout: %v\n", err)
                }</span>
        }()

        // Stream stderr
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                if err := l.streamToFile(stderr, l.config.ErrFile, "stderr", stopCh); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "[prox] Error streaming stderr: %v\n", err)
                }</span>
        }()
}

// streamToFile streams data from reader to file with rotation
func (l *Logger) streamToFile(reader io.Reader, filepath, stream string, stopCh &lt;-chan struct{}) error <span class="cov0" title="0">{
        file, err := l.openLogFile(filepath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        scanner := bufio.NewScanner(reader)
        scanner.Buffer(make([]byte, 64*1024), 1024*1024) // 64KB buffer, 1MB max

        for scanner.Scan() </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-stopCh:<span class="cov0" title="0">
                        return nil</span>
                default:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">line := scanner.Text()
                timestamp := time.Now().Format("2006-01-02 15:04:05")
                logLine := fmt.Sprintf("[%s] %s\n", timestamp, line)

                // Write to file
                if stream == "stdout" </span><span class="cov0" title="0">{
                        l.outMu.Lock()
                        _, err := file.WriteString(logLine)
                        file.Sync() // Flush to disk
                        l.outMu.Unlock()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        l.errMu.Lock()
                        _, err := file.WriteString(logLine)
                        file.Sync() // Flush to disk
                        l.errMu.Unlock()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                // Check if rotation is needed
                <span class="cov0" title="0">if err := l.rotateIfNeeded(file, filepath); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return scanner.Err()</span>
}

// openLogFile opens or creates a log file
func (l *Logger) openLogFile(filepath string) (*os.File, error) <span class="cov0" title="0">{
        // Open file in append mode (directory should already exist from storage initialization)
        file, err := os.OpenFile(filepath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return file, nil</span>
}

// rotateIfNeeded checks file size and rotates if necessary
func (l *Logger) rotateIfNeeded(file *os.File, filepath string) error <span class="cov0" title="0">{
        stat, err := file.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if stat.Size() &gt;= l.config.MaxSize </span><span class="cov0" title="0">{
                return l.rotateLog(filepath)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// rotateLog rotates the log file
func (l *Logger) rotateLog(filepath string) error <span class="cov0" title="0">{
        // Close current file (will be reopened by caller)

        // Rotate existing files
        for i := l.config.MaxFiles - 1; i &gt; 0; i-- </span><span class="cov0" title="0">{
                oldPath := fmt.Sprintf("%s.%d", filepath, i)
                newPath := fmt.Sprintf("%s.%d", filepath, i+1)

                if _, err := os.Stat(oldPath); err == nil </span><span class="cov0" title="0">{
                        os.Rename(oldPath, newPath)
                }</span>
        }

        // Rotate current file to .1
        <span class="cov0" title="0">newPath := fmt.Sprintf("%s.1", filepath)
        if err := os.Rename(filepath, newPath); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Delete oldest file if exceeds max
        <span class="cov0" title="0">oldestPath := fmt.Sprintf("%s.%d", filepath, l.config.MaxFiles+1)
        os.Remove(oldestPath)

        return nil</span>
}

// ReadTail reads the last n lines from a log file
func ReadTail(filepath string, n int) ([]string, error) <span class="cov0" title="0">{
        file, err := os.Open(filepath)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return []string{}, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">defer file.Close()

        var lines []string
        scanner := bufio.NewScanner(file)

        // Read all lines (TODO: optimize for large files)
        for scanner.Scan() </span><span class="cov0" title="0">{
                lines = append(lines, scanner.Text())
        }</span>

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Return last n lines (n == 0 means return all lines)
        <span class="cov0" title="0">if n &gt; 0 &amp;&amp; len(lines) &gt; n </span><span class="cov0" title="0">{
                return lines[len(lines)-n:], nil
        }</span>

        <span class="cov0" title="0">return lines, nil</span>
}

// ReadAll reads all lines from a log file
func ReadAll(filepath string) ([]string, error) <span class="cov0" title="0">{
        file, err := os.Open(filepath)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return []string{}, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">defer file.Close()

        var lines []string
        scanner := bufio.NewScanner(file)
        scanner.Buffer(make([]byte, 64*1024), 1024*1024)

        for scanner.Scan() </span><span class="cov0" title="0">{
                lines = append(lines, scanner.Text())
        }</span>

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return lines, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package logs

import (
        "sort"
        "strings"
        "time"

        "github.com/craigderington/prox/internal/storage"
)

// LogSource represents the source of a log entry
type LogSource string

const (
        LogSourceStdout LogSource = "stdout"
        LogSourceStderr LogSource = "stderr"
)

// LogEntry represents a single log line with metadata
type LogEntry struct {
        Timestamp time.Time
        Source    LogSource
        Content   string
}

// MergeLogs reads and merges stdout and stderr logs chronologically
// Returns the last N lines merged by timestamp
func MergeLogs(storage *storage.Storage, processName string, tailLines int) ([]LogEntry, error) <span class="cov0" title="0">{
        outPath := storage.GetLogFile(processName, "out")
        errPath := storage.GetLogFile(processName, "err")

        // Read log files
        outLines, err := ReadTail(outPath, tailLines)
        if err != nil </span><span class="cov0" title="0">{
                // If error reading, continue with empty slice (file might not exist yet)
                outLines = []string{}
        }</span>

        <span class="cov0" title="0">errLines, err := ReadTail(errPath, tailLines)
        if err != nil </span><span class="cov0" title="0">{
                errLines = []string{}
        }</span>

        // Parse and merge
        <span class="cov0" title="0">entries := make([]LogEntry, 0, len(outLines)+len(errLines))

        for _, line := range outLines </span><span class="cov0" title="0">{
                ts, content := parseLogLine(line)
                entries = append(entries, LogEntry{
                        Timestamp: ts,
                        Source:    LogSourceStdout,
                        Content:   content,
                })
        }</span>

        <span class="cov0" title="0">for _, line := range errLines </span><span class="cov0" title="0">{
                ts, content := parseLogLine(line)
                entries = append(entries, LogEntry{
                        Timestamp: ts,
                        Source:    LogSourceStderr,
                        Content:   content,
                })
        }</span>

        // Sort by timestamp (stable sort preserves order for identical timestamps)
        <span class="cov0" title="0">sort.SliceStable(entries, func(i, j int) bool </span><span class="cov0" title="0">{
                return entries[i].Timestamp.Before(entries[j].Timestamp)
        }</span>)

        // Return last N entries if we have more than requested
        <span class="cov0" title="0">if len(entries) &gt; tailLines &amp;&amp; tailLines &gt; 0 </span><span class="cov0" title="0">{
                return entries[len(entries)-tailLines:], nil
        }</span>

        <span class="cov0" title="0">return entries, nil</span>
}

// parseLogLine extracts timestamp and content from a log line
// Format: [2006-01-02 15:04:05] content here
// Returns (timestamp, content) or (zero time, original line) if no timestamp
func parseLogLine(line string) (time.Time, string) <span class="cov0" title="0">{
        if len(line) &lt; 21 </span><span class="cov0" title="0">{
                return time.Time{}, line
        }</span>

        <span class="cov0" title="0">if line[0] != '[' </span><span class="cov0" title="0">{
                return time.Time{}, line
        }</span>

        <span class="cov0" title="0">closeBracket := strings.Index(line, "]")
        if closeBracket == -1 || closeBracket &lt; 19 </span><span class="cov0" title="0">{
                return time.Time{}, line
        }</span>

        <span class="cov0" title="0">timestampStr := line[1:closeBracket]
        ts, err := time.Parse("2006-01-02 15:04:05", timestampStr)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, line
        }</span>

        // Return parsed timestamp and content after "] "
        <span class="cov0" title="0">content := line
        if closeBracket+2 &lt; len(line) </span><span class="cov0" title="0">{
                content = line[closeBracket+2:]
        }</span> else<span class="cov0" title="0"> if closeBracket+1 &lt; len(line) </span><span class="cov0" title="0">{
                content = line[closeBracket+1:]
        }</span>

        <span class="cov0" title="0">return ts, content</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package manager

import (
        "fmt"
        "sync"

        "github.com/craigderington/prox/internal/process"
        "github.com/craigderington/prox/internal/storage"
)

var (
        instance     *process.Manager
        storageInst  *storage.Storage
        instanceOnce sync.Once
        instanceErr  error
)

// Get returns the shared process manager instance
func Get() (*process.Manager, *storage.Storage, error) <span class="cov0" title="0">{
        instanceOnce.Do(func() </span><span class="cov0" title="0">{
                // Initialize storage
                storageInst, instanceErr = storage.New()
                if instanceErr != nil </span><span class="cov0" title="0">{
                        instanceErr = fmt.Errorf("failed to initialize storage: %w", instanceErr)
                        return
                }</span>

                // Create manager
                <span class="cov0" title="0">instance = process.NewManager()

                // Set storage on manager for logging
                instance.SetStorage(storageInst)

                // Load state from disk
                if err := instance.LoadState(storageInst); err != nil </span><span class="cov0" title="0">{
                        instanceErr = fmt.Errorf("failed to load state: %w", err)
                        return
                }</span>

                // Restore monitoring for running processes
                <span class="cov0" title="0">if err := instance.RestoreRunningProcesses(); err != nil </span><span class="cov0" title="0">{
                        instanceErr = fmt.Errorf("failed to restore processes: %w", err)
                        return
                }</span>
        })

        <span class="cov0" title="0">return instance, storageInst, instanceErr</span>
}

// Save saves the current manager state
func Save() error <span class="cov0" title="0">{
        if instance == nil || storageInst == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("manager not initialized")
        }</span>
        <span class="cov0" title="0">return instance.SaveState(storageInst)</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package process

import (
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "sort"
        "sync"
        "syscall"
        "time"

        "github.com/google/uuid"
)

// Manager manages all processes in the prox system.
// It handles process lifecycle, monitoring, and coordination.
type Manager struct {
        processes map[string]*Process
        mu        sync.RWMutex
        storage   Storage
}

// Storage interface for log paths
type Storage interface {
        GetLogFile(name, stream string) string
        LogsDir() string
}

// NewManager creates a new process manager
func NewManager() *Manager <span class="cov8" title="1">{
        return &amp;Manager{
                processes: make(map[string]*Process),
        }
}</span>

// SetStorage sets the storage backend for the manager
func (m *Manager) SetStorage(storage Storage) <span class="cov8" title="1">{
        m.storage = storage
}</span>

// Start starts a new process with the given configuration.
// It validates the config, spawns the process, and begins monitoring.
// Returns the process instance and any error that occurred.
func (m *Manager) Start(config ProcessConfig) (*Process, error) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        // Check if a process with this name already exists
        for _, p := range m.processes </span><span class="cov8" title="1">{
                if p.Name == config.Name </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("process '%s' already exists", config.Name)
                }</span>
        }

        // Set default restart policy
        <span class="cov8" title="1">restartPolicy := config.Restart
        if restartPolicy == "" </span><span class="cov8" title="1">{
                restartPolicy = RestartOnFailure
        }</span>

        // Create process
        <span class="cov8" title="1">proc := &amp;Process{
                ID:            uuid.New().String(),
                Name:          config.Name,
                Script:        config.Script,
                Interpreter:   config.Interpreter,
                Args:          config.Args,
                Cwd:           config.Cwd,
                Status:        StatusStopped,
                RestartPolicy: restartPolicy,
                DependsOn:     config.DependsOn,
                stopCh:        make(chan struct{}),
                logStopCh:     make(chan struct{}),
                manager:       m,
        }

        // Prepare environment variables
        env := os.Environ()
        for k, v := range config.Env </span><span class="cov0" title="0">{
                env = append(env, fmt.Sprintf("%s=%s", k, v))
        }</span>
        <span class="cov8" title="1">proc.Env = env

        // Set working directory to current dir if not specified
        if proc.Cwd == "" </span><span class="cov8" title="1">{
                proc.Cwd, _ = os.Getwd()
        }</span>

        // Start the process
        <span class="cov8" title="1">if err := m.startProcess(proc); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">m.processes[proc.ID] = proc
        return proc, nil</span>
}

// startProcess actually spawns the process
func (m *Manager) startProcess(proc *Process) error <span class="cov8" title="1">{
        // Build command
        var cmd *exec.Cmd
        if proc.Interpreter != "" </span><span class="cov0" title="0">{
                // Use interpreter (e.g., node app.js)
                args := append([]string{proc.Script}, proc.Args...)
                cmd = exec.Command(proc.Interpreter, args...)
        }</span> else<span class="cov8" title="1"> {
                // Direct execution
                cmd = exec.Command(proc.Script, proc.Args...)
        }</span>

        <span class="cov8" title="1">cmd.Dir = proc.Cwd
        cmd.Env = proc.Env

        // Set up process group for proper signal propagation on Unix
        cmd.SysProcAttr = &amp;syscall.SysProcAttr{
                Setpgid: true,
        }

        // Set up log files if storage is available
        if m.storage != nil </span><span class="cov8" title="1">{
                outFile, err := os.OpenFile(
                        m.storage.GetLogFile(proc.Name, "out"),
                        os.O_CREATE|os.O_WRONLY|os.O_APPEND,
                        0644,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to open stdout log: %w", err)
                }</span>

                <span class="cov8" title="1">errFile, err := os.OpenFile(
                        m.storage.GetLogFile(proc.Name, "err"),
                        os.O_CREATE|os.O_WRONLY|os.O_APPEND,
                        0644,
                )
                if err != nil </span><span class="cov0" title="0">{
                        outFile.Close()
                        return fmt.Errorf("failed to open stderr log: %w", err)
                }</span>

                // Redirect stdout/stderr to log files
                <span class="cov8" title="1">cmd.Stdout = outFile
                cmd.Stderr = errFile

                // Store file handles for cleanup later
                proc.logFiles.stdout = outFile
                proc.logFiles.stderr = errFile</span>
        }

        // Start the process
        <span class="cov8" title="1">if err := cmd.Start(); err != nil </span><span class="cov0" title="0">{
                // Clean up log files if start failed
                if proc.logFiles.stdout != nil </span><span class="cov0" title="0">{
                        proc.logFiles.stdout.Close()
                        proc.logFiles.stdout = nil
                }</span>
                <span class="cov0" title="0">if proc.logFiles.stderr != nil </span><span class="cov0" title="0">{
                        proc.logFiles.stderr.Close()
                        proc.logFiles.stderr = nil
                }</span>
                <span class="cov0" title="0">proc.Status = StatusErrored
                return fmt.Errorf("failed to start process: %w", err)</span>
        }

        <span class="cov8" title="1">proc.cmd = cmd
        proc.PID = cmd.Process.Pid
        proc.Status = StatusOnline
        proc.StartedAt = time.Now()
        proc.StoppedAt = nil

        // Monitor process in background
        go m.monitorProcess(proc)

        return nil</span>
}

// monitorProcess watches a process and handles crashes
func (m *Manager) monitorProcess(proc *Process) <span class="cov8" title="1">{
        err := proc.cmd.Wait()

        proc.mu.Lock()
        defer proc.mu.Unlock()

        // Check if this was an intentional stop
        select </span>{
        case &lt;-proc.stopCh:<span class="cov8" title="1">
                // Intentional stop
                proc.Status = StatusStopped
                now := time.Now()
                proc.StoppedAt = &amp;now
                return</span>
        default:<span class="cov8" title="1"></span>
        }

        // Unexpected exit
        <span class="cov8" title="1">proc.Restarts++
        exitCode := 0
        if err != nil </span><span class="cov0" title="0">{
                if exitErr, ok := err.(*exec.ExitError); ok </span><span class="cov0" title="0">{
                        exitCode = exitErr.ExitCode()
                }</span>
        }

        // Log the error
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "[prox] Process '%s' (PID %d) exited with error (code %d): %v\n",
                        proc.Name, proc.PID, exitCode, err)
        }</span> else<span class="cov8" title="1"> {
                fmt.Fprintf(os.Stderr, "[prox] Process '%s' (PID %d) exited unexpectedly\n",
                        proc.Name, proc.PID)
        }</span>

        // Determine if we should restart based on policy
        <span class="cov8" title="1">shouldRestart := false
        switch proc.RestartPolicy </span>{
        case RestartAlways:<span class="cov0" title="0">
                shouldRestart = true
                fmt.Fprintf(os.Stderr, "[prox] Restarting '%s' (policy: always)...\n", proc.Name)</span>
        case RestartOnFailure:<span class="cov8" title="1">
                if exitCode != 0 </span><span class="cov0" title="0">{
                        shouldRestart = true
                        fmt.Fprintf(os.Stderr, "[prox] Restarting '%s' (policy: on-failure, exit code: %d)...\n",
                                proc.Name, exitCode)
                }</span>
        case RestartNever:<span class="cov0" title="0">
                shouldRestart = false</span>
        }

        <span class="cov8" title="1">if shouldRestart </span><span class="cov0" title="0">{
                // Close old log files
                if proc.logFiles.stdout != nil </span><span class="cov0" title="0">{
                        proc.logFiles.stdout.Close()
                        proc.logFiles.stdout = nil
                }</span>
                <span class="cov0" title="0">if proc.logFiles.stderr != nil </span><span class="cov0" title="0">{
                        proc.logFiles.stderr.Close()
                        proc.logFiles.stderr = nil
                }</span>

                // Recreate channels
                <span class="cov0" title="0">proc.stopCh = make(chan struct{})
                proc.logStopCh = make(chan struct{})

                // Brief delay before restart
                time.Sleep(1 * time.Second)

                // Attempt restart
                if err := m.startProcess(proc); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "[prox] Failed to restart '%s': %v\n", proc.Name, err)
                        proc.Status = StatusErrored
                        now := time.Now()
                        proc.StoppedAt = &amp;now
                }</span>
        } else<span class="cov8" title="1"> {
                // Mark as errored without restarting
                proc.Status = StatusErrored
                now := time.Now()
                proc.StoppedAt = &amp;now

                // Close log files
                if proc.logFiles.stdout != nil </span><span class="cov8" title="1">{
                        proc.logFiles.stdout.Close()
                        proc.logFiles.stdout = nil
                }</span>
                <span class="cov8" title="1">if proc.logFiles.stderr != nil </span><span class="cov8" title="1">{
                        proc.logFiles.stderr.Close()
                        proc.logFiles.stderr = nil
                }</span>
        }
}

// Stop stops a process by name or ID.
// It performs a graceful shutdown with SIGTERM, then SIGKILL if needed.
// Returns an error if the process is not found or cannot be stopped.
func (m *Manager) Stop(nameOrID string) error <span class="cov8" title="1">{
        m.mu.RLock()
        proc := m.findProcess(nameOrID)
        m.mu.RUnlock()

        if proc == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("process not found: %s", nameOrID)
        }</span>

        <span class="cov8" title="1">return m.stopProcess(proc)</span>
}

// stopProcess stops a specific process
func (m *Manager) stopProcess(proc *Process) error <span class="cov8" title="1">{
        proc.mu.Lock()
        defer proc.mu.Unlock()

        if proc.Status == StatusStopped </span><span class="cov0" title="0">{
                return fmt.Errorf("process '%s' is already stopped", proc.Name)
        }</span>

        // Handle case where we reconnected to a process (cmd is nil but PID exists)
        <span class="cov8" title="1">if proc.cmd == nil || proc.cmd.Process == nil </span><span class="cov0" title="0">{
                if proc.PID &gt; 0 &amp;&amp; processExists(proc.PID) </span><span class="cov0" title="0">{
                        // We have a PID but no cmd - this happens when reconnecting to a process
                        // Kill the process group directly
                        if err := syscall.Kill(-proc.PID, syscall.SIGTERM); err != nil </span><span class="cov0" title="0">{
                                // Fallback to killing just the process
                                if err := syscall.Kill(proc.PID, syscall.SIGTERM); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to send SIGTERM to PID %d: %w", proc.PID, err)
                                }</span>
                        }

                        // Wait for process to exit (up to 5 seconds)
                        <span class="cov0" title="0">for i := 0; i &lt; 50; i++ </span><span class="cov0" title="0">{
                                if !processExists(proc.PID) </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov0" title="0">time.Sleep(100 * time.Millisecond)</span>
                        }

                        // Force kill if still running
                        <span class="cov0" title="0">if processExists(proc.PID) </span><span class="cov0" title="0">{
                                syscall.Kill(-proc.PID, syscall.SIGKILL)
                                syscall.Kill(proc.PID, syscall.SIGKILL) // Fallback
                                time.Sleep(500 * time.Millisecond)
                        }</span>
                }

                <span class="cov0" title="0">proc.Status = StatusStopped
                now := time.Now()
                proc.StoppedAt = &amp;now
                return nil</span>
        }

        <span class="cov8" title="1">proc.Status = StatusStopping

        // Signal that this is an intentional stop
        close(proc.stopCh)

        // Stop log streaming
        close(proc.logStopCh)

        // Try graceful shutdown with SIGTERM
        // Use negative PID to signal the entire process group (since we used Setpgid: true)
        // This ensures child processes also receive the signal and release resources like ports
        pgid := proc.PID
        if err := syscall.Kill(-pgid, syscall.SIGTERM); err != nil </span><span class="cov0" title="0">{
                // Fallback to signaling just the parent process if process group signal fails
                if err := proc.cmd.Process.Signal(syscall.SIGTERM); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to send SIGTERM: %w", err)
                }</span>
        }

        // Wait for graceful shutdown (5 seconds)
        <span class="cov8" title="1">done := make(chan error, 1)
        go func() </span><span class="cov8" title="1">{
                done &lt;- proc.cmd.Wait()
        }</span>()

        <span class="cov8" title="1">select </span>{
        case &lt;-time.After(5 * time.Second):<span class="cov0" title="0">
                // Force kill after timeout - signal entire process group
                if err := syscall.Kill(-pgid, syscall.SIGKILL); err != nil </span><span class="cov0" title="0">{
                        // Fallback to killing just the parent if process group kill fails
                        if err := proc.cmd.Process.Kill(); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to kill process: %w", err)
                        }</span>
                }
                <span class="cov0" title="0">&lt;-done</span> // Wait for Wait() to finish
        case &lt;-done:<span class="cov8" title="1"></span>
                // Process exited gracefully
        }

        <span class="cov8" title="1">proc.Status = StatusStopped
        now := time.Now()
        proc.StoppedAt = &amp;now

        // Close log files
        if proc.logFiles.stdout != nil </span><span class="cov8" title="1">{
                proc.logFiles.stdout.Close()
                proc.logFiles.stdout = nil
        }</span>
        <span class="cov8" title="1">if proc.logFiles.stderr != nil </span><span class="cov8" title="1">{
                proc.logFiles.stderr.Close()
                proc.logFiles.stderr = nil
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Restart restarts a process
func (m *Manager) Restart(nameOrID string) error <span class="cov8" title="1">{
        m.mu.RLock()
        proc := m.findProcess(nameOrID)
        m.mu.RUnlock()

        if proc == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("process not found: %s", nameOrID)
        }</span>

        <span class="cov8" title="1">proc.mu.Lock()
        proc.Status = StatusRestarting
        proc.mu.Unlock()

        // Stop the process if it's running
        if proc.Status == StatusOnline </span><span class="cov0" title="0">{
                if err := m.stopProcess(proc); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Recreate stop channels
        <span class="cov8" title="1">proc.stopCh = make(chan struct{})
        proc.logStopCh = make(chan struct{})

        // Start it again
        return m.startProcess(proc)</span>
}

// Delete removes a process (stops it first if running)
func (m *Manager) Delete(nameOrID string) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        proc := m.findProcess(nameOrID)
        if proc == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("process not found: %s", nameOrID)
        }</span>

        // Stop if running
        <span class="cov8" title="1">if proc.Status == StatusOnline </span><span class="cov8" title="1">{
                if err := m.stopProcess(proc); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Remove from map
        <span class="cov8" title="1">delete(m.processes, proc.ID)
        return nil</span>
}

// List returns all managed processes sorted alphabetically by name.
// The returned slice is a copy and can be safely modified by the caller.
func (m *Manager) List() []*Process <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        processes := make([]*Process, 0, len(m.processes))
        for _, proc := range m.processes </span><span class="cov8" title="1">{
                processes = append(processes, proc)
        }</span>

        // Sort alphabetically by name for consistent ordering
        <span class="cov8" title="1">sort.Slice(processes, func(i, j int) bool </span><span class="cov8" title="1">{
                return processes[i].Name &lt; processes[j].Name
        }</span>)

        <span class="cov8" title="1">return processes</span>
}

// Get returns a process by name or ID.
// Returns nil if no process is found with the given identifier.
func (m *Manager) Get(nameOrID string) *Process <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.findProcess(nameOrID)
}</span>

// findProcess finds a process by name or ID (must be called with lock held)
func (m *Manager) findProcess(nameOrID string) *Process <span class="cov8" title="1">{
        // Try by ID first
        if proc, ok := m.processes[nameOrID]; ok </span><span class="cov8" title="1">{
                return proc
        }</span>

        // Try by name
        <span class="cov8" title="1">for _, proc := range m.processes </span><span class="cov8" title="1">{
                if proc.Name == nameOrID </span><span class="cov8" title="1">{
                        return proc
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// StopAll stops all running processes
func (m *Manager) StopAll() error <span class="cov0" title="0">{
        m.mu.RLock()
        processes := make([]*Process, 0, len(m.processes))
        for _, proc := range m.processes </span><span class="cov0" title="0">{
                if proc.Status == StatusOnline </span><span class="cov0" title="0">{
                        processes = append(processes, proc)
                }</span>
        }
        <span class="cov0" title="0">m.mu.RUnlock()

        var lastErr error
        for _, proc := range processes </span><span class="cov0" title="0">{
                if err := m.stopProcess(proc); err != nil </span><span class="cov0" title="0">{
                        lastErr = err
                        fmt.Fprintf(os.Stderr, "[prox] Error stopping '%s': %v\n", proc.Name, err)
                }</span>
        }

        <span class="cov0" title="0">return lastErr</span>
}

// ConfigDir returns the prox configuration directory
func ConfigDir() (string, error) <span class="cov0" title="0">{
        home, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">configDir := filepath.Join(home, ".prox")
        return configDir, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package process

import (
        "fmt"
        "time"

        "github.com/shirou/gopsutil/v3/cpu"
        "github.com/shirou/gopsutil/v3/net"
        gopsutil_process "github.com/shirou/gopsutil/v3/process"
)

// MetricsCollector collects metrics for all managed processes
type MetricsCollector struct {
        manager *Manager
}

// NewMetricsCollector creates a new metrics collector
func NewMetricsCollector(manager *Manager) *MetricsCollector <span class="cov0" title="0">{
        return &amp;MetricsCollector{
                manager: manager,
        }
}</span>

// CollectMetrics collects metrics for a specific process
func (mc *MetricsCollector) CollectMetrics(proc *Process) (*ProcessMetrics, error) <span class="cov0" title="0">{
        proc.mu.RLock()
        pid := proc.PID
        status := proc.Status
        startedAt := proc.StartedAt
        proc.mu.RUnlock()

        // If process is not online, return empty metrics
        if status != StatusOnline || pid &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ProcessMetrics{
                        PID:    pid,
                        Uptime: 0,
                }, nil
        }</span>

        // Get process handle from gopsutil
        <span class="cov0" title="0">p, err := gopsutil_process.NewProcess(int32(pid))
        if err != nil </span><span class="cov0" title="0">{
                // Process might have just exited
                return &amp;ProcessMetrics{
                        PID:    pid,
                        Uptime: time.Since(startedAt),
                }, nil
        }</span>

        // Collect CPU percentage
        <span class="cov0" title="0">cpuPercent, err := p.CPUPercent()
        if err != nil </span><span class="cov0" title="0">{
                cpuPercent = 0
        }</span>

        // Collect memory info
        <span class="cov0" title="0">memInfo, err := p.MemoryInfo()
        var memory uint64
        var memoryPercent float64
        if err == nil &amp;&amp; memInfo != nil </span><span class="cov0" title="0">{
                memory = memInfo.RSS
                // Calculate memory percentage
                memPercent, err := p.MemoryPercent()
                if err == nil </span><span class="cov0" title="0">{
                        memoryPercent = float64(memPercent)
                }</span>
        }

        // Collect system-wide network IO (per-process network accounting is complex and not reliably available)
        // This provides system network totals as a proxy for process network activity
        <span class="cov0" title="0">var netSent, netRecv uint64
        counters, err := net.IOCounters(false) // false = aggregate all interfaces
        if err == nil &amp;&amp; len(counters) &gt; 0 </span><span class="cov0" title="0">{
                // Use the first (aggregated) counter
                netSent = counters[0].BytesSent
                netRecv = counters[0].BytesRecv
        }</span>

        <span class="cov0" title="0">return &amp;ProcessMetrics{
                PID:           pid,
                CPU:           cpuPercent,
                Memory:        memory,
                MemoryPercent: memoryPercent,
                Uptime:        time.Since(startedAt),
                NetSent:       netSent,
                NetRecv:       netRecv,
        }, nil</span>
}

// CollectAllMetrics collects metrics for all managed processes
func (mc *MetricsCollector) CollectAllMetrics() map[string]*ProcessMetrics <span class="cov0" title="0">{
        processes := mc.manager.List()
        metrics := make(map[string]*ProcessMetrics)

        for _, proc := range processes </span><span class="cov0" title="0">{
                m, err := mc.CollectMetrics(proc)
                if err != nil </span><span class="cov0" title="0">{
                        // Log error but continue
                        fmt.Printf("[prox] Error collecting metrics for %s: %v\n", proc.Name, err)
                        continue</span>
                }
                <span class="cov0" title="0">metrics[proc.ID] = m</span>
        }

        <span class="cov0" title="0">return metrics</span>
}

// GetSystemCPU returns overall system CPU usage
func GetSystemCPU() (float64, error) <span class="cov0" title="0">{
        percentages, err := cpu.Percent(time.Second, false)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">if len(percentages) &gt; 0 </span><span class="cov0" title="0">{
                return percentages[0], nil
        }</span>
        <span class="cov0" title="0">return 0, nil</span>
}

// FormatBytes formats bytes into human-readable string
func FormatBytes(bytes uint64) string <span class="cov0" title="0">{
        const unit = 1024
        if bytes &lt; unit </span><span class="cov0" title="0">{
                return fmt.Sprintf("%d B", bytes)
        }</span>
        <span class="cov0" title="0">div, exp := uint64(unit), 0
        for n := bytes / unit; n &gt;= unit; n /= unit </span><span class="cov0" title="0">{
                div *= unit
                exp++
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%.1f %cB", float64(bytes)/float64(div), "KMGTPE"[exp])</span>
}

// FormatDuration formats a duration into human-readable string
func FormatDuration(d time.Duration) string <span class="cov0" title="0">{
        if d &lt; time.Minute </span><span class="cov0" title="0">{
                return fmt.Sprintf("%ds", int(d.Seconds()))
        }</span>
        <span class="cov0" title="0">if d &lt; time.Hour </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dm%ds", int(d.Minutes()), int(d.Seconds())%60)
        }</span>
        <span class="cov0" title="0">if d &lt; 24*time.Hour </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dh%dm", int(d.Hours()), int(d.Minutes())%60)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%dd%dh", int(d.Hours())/24, int(d.Hours())%24)</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package process

import (
        "fmt"
        "os"
        "syscall"
        "time"

        "github.com/craigderington/prox/internal/storage"
)

// ProcessState represents the persistent state of a process
type ProcessState struct {
        ID          string        `json:"id"`
        Name        string        `json:"name"`
        Script      string        `json:"script"`
        Interpreter string        `json:"interpreter"`
        Args        []string      `json:"args"`
        Cwd         string        `json:"cwd"`
        Env         []string      `json:"env"`
        PID         int           `json:"pid"`
        Status      ProcessStatus `json:"status"`
        Restarts    int           `json:"restarts"`
        StartedAt   time.Time     `json:"started_at"`
        StoppedAt   *time.Time    `json:"stopped_at,omitempty"`
}

// ManagerState represents the persistent state of the manager
type ManagerState struct {
        Processes []ProcessState `json:"processes"`
}

// SaveState saves the current manager state to disk
func (m *Manager) SaveState(storage *storage.Storage) error <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        state := ManagerState{
                Processes: make([]ProcessState, 0, len(m.processes)),
        }

        for _, proc := range m.processes </span><span class="cov0" title="0">{
                proc.mu.RLock()
                state.Processes = append(state.Processes, ProcessState{
                        ID:          proc.ID,
                        Name:        proc.Name,
                        Script:      proc.Script,
                        Interpreter: proc.Interpreter,
                        Args:        proc.Args,
                        Cwd:         proc.Cwd,
                        Env:         proc.Env,
                        PID:         proc.PID,
                        Status:      proc.Status,
                        Restarts:    proc.Restarts,
                        StartedAt:   proc.StartedAt,
                        StoppedAt:   proc.StoppedAt,
                })
                proc.mu.RUnlock()
        }</span>

        <span class="cov0" title="0">return storage.SaveState(state)</span>
}

// LoadState loads the manager state from disk
func (m *Manager) LoadState(storage *storage.Storage) error <span class="cov0" title="0">{
        var state ManagerState
        if err := storage.LoadState(&amp;state); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">m.mu.Lock()
        defer m.mu.Unlock()

        for _, procState := range state.Processes </span><span class="cov0" title="0">{
                proc := &amp;Process{
                        ID:          procState.ID,
                        Name:        procState.Name,
                        Script:      procState.Script,
                        Interpreter: procState.Interpreter,
                        Args:        procState.Args,
                        Cwd:         procState.Cwd,
                        Env:         procState.Env,
                        PID:         procState.PID,
                        Status:      procState.Status,
                        Restarts:    procState.Restarts,
                        StartedAt:   procState.StartedAt,
                        StoppedAt:   procState.StoppedAt,
                        stopCh:      make(chan struct{}),
                        logStopCh:   make(chan struct{}),
                }

                // If process was online when saved, try to verify it's still running
                if proc.Status == StatusOnline </span><span class="cov0" title="0">{
                        // Check if process still exists
                        if !processExists(proc.PID) </span><span class="cov0" title="0">{
                                proc.Status = StatusErrored
                                now := time.Now()
                                proc.StoppedAt = &amp;now
                        }</span>
                }

                <span class="cov0" title="0">m.processes[proc.ID] = proc</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// processExists checks if a process with the given PID is running
func processExists(pid int) bool <span class="cov0" title="0">{
        if pid &lt;= 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">process, err := os.FindProcess(pid)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        // On Unix, sending signal 0 checks if process exists without actually sending a signal
        <span class="cov0" title="0">err = process.Signal(syscall.Signal(0))
        return err == nil</span>
}

// SaveState saves manager state (convenience wrapper)
func SaveState(m *Manager, storage *storage.Storage) error <span class="cov0" title="0">{
        return m.SaveState(storage)
}</span>

// LoadState loads manager state (convenience wrapper)
func LoadState(m *Manager, storage *storage.Storage) error <span class="cov0" title="0">{
        return m.LoadState(storage)
}</span>

// RestoreRunningProcesses attempts to restore monitoring for running processes
func (m *Manager) RestoreRunningProcesses() error <span class="cov0" title="0">{
        m.mu.RLock()
        processes := make([]*Process, 0)
        for _, proc := range m.processes </span><span class="cov0" title="0">{
                if proc.Status == StatusOnline </span><span class="cov0" title="0">{
                        processes = append(processes, proc)
                }</span>
        }
        <span class="cov0" title="0">m.mu.RUnlock()

        for _, proc := range processes </span><span class="cov0" title="0">{
                // Try to reconnect to running process
                if processExists(proc.PID) </span><span class="cov0" title="0">{
                        fmt.Printf("[prox] Reconnected to process '%s' (PID %d)\n", proc.Name, proc.PID)
                        // TODO: Restore monitoring goroutine if needed
                }</span> else<span class="cov0" title="0"> {
                        proc.mu.Lock()
                        proc.Status = StatusErrored
                        now := time.Now()
                        proc.StoppedAt = &amp;now
                        proc.mu.Unlock()
                        fmt.Printf("[prox] Process '%s' is no longer running\n", proc.Name)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package process

import (
        "os"
        "os/exec"
        "sync"
        "time"
)

// ProcessStatus represents the current state of a process
type ProcessStatus string

const (
        StatusOnline     ProcessStatus = "online"
        StatusStopped    ProcessStatus = "stopped"
        StatusErrored    ProcessStatus = "errored"
        StatusRestarting ProcessStatus = "restarting"
        StatusStopping   ProcessStatus = "stopping"
)

// Process represents a managed process with its configuration and runtime state.
type Process struct {
        ID            string        `json:"id"`
        Name          string        `json:"name"`
        Script        string        `json:"script"`
        Interpreter   string        `json:"interpreter"` // e.g., "node", "python", "go", ""
        Args          []string      `json:"args"`
        Cwd           string        `json:"cwd"`
        Env           []string      `json:"env"`
        PID           int           `json:"pid"`
        Status        ProcessStatus `json:"status"`
        Restarts      int           `json:"restarts"`
        StartedAt     time.Time     `json:"started_at"`
        StoppedAt     *time.Time    `json:"stopped_at,omitempty"`
        RestartPolicy RestartPolicy `json:"restart_policy"`
        DependsOn     []string      `json:"depends_on,omitempty"`

        // Runtime state (not persisted)
        cmd       *exec.Cmd
        mu        sync.RWMutex
        stopCh    chan struct{}
        logStopCh chan struct{}
        logFiles  struct {
                stdout *os.File
                stderr *os.File
        }
        manager *Manager // Reference to manager for auto-restart
}

// ProcessMetrics holds real-time metrics for a process.
// Note: NetSent and NetRecv represent system-wide network metrics,
// not per-process metrics (which are difficult to obtain accurately).
type ProcessMetrics struct {
        PID           int
        CPU           float64
        Memory        uint64 // bytes
        MemoryPercent float64
        Uptime        time.Duration
        NetSent       uint64 // system-wide bytes sent (network accounting per-process is complex)
        NetRecv       uint64 // system-wide bytes received (network accounting per-process is complex)
}

// RestartPolicy defines how a process should be restarted
type RestartPolicy string

const (
        RestartAlways    RestartPolicy = "always"
        RestartOnFailure RestartPolicy = "on-failure"
        RestartNever     RestartPolicy = "never"
)

// ProcessConfig is the configuration for starting a process.
// It defines how a process should be executed and managed.
type ProcessConfig struct {
        Name        string            `json:"name"`
        Script      string            `json:"script"`
        Interpreter string            `json:"interpreter,omitempty"`
        Args        []string          `json:"args,omitempty"`
        Cwd         string            `json:"cwd,omitempty"`
        Env         map[string]string `json:"env,omitempty"`
        Restart     RestartPolicy     `json:"restart,omitempty"`
        DependsOn   []string          `json:"depends_on,omitempty"`
}

// Uptime returns how long the process has been running
func (p *Process) Uptime() time.Duration <span class="cov0" title="0">{
        p.mu.RLock()
        defer p.mu.RUnlock()

        if p.Status != StatusOnline </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return time.Since(p.StartedAt)</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package storage

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
)

// Storage handles persistence of process manager state
type Storage struct {
        configDir string
}

// New creates a new storage instance
func New() (*Storage, error) <span class="cov8" title="1">{
        home, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get home directory: %w", err)
        }</span>

        <span class="cov8" title="1">configDir := filepath.Join(home, ".prox")

        // Create config directory if it doesn't exist
        if err := os.MkdirAll(configDir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create config directory: %w", err)
        }</span>

        // Create subdirectories
        <span class="cov8" title="1">subdirs := []string{"processes", "logs", "pids"}
        for _, subdir := range subdirs </span><span class="cov8" title="1">{
                dir := filepath.Join(configDir, subdir)
                if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create %s directory: %w", subdir, err)
                }</span>
        }

        <span class="cov8" title="1">return &amp;Storage{
                configDir: configDir,
        }, nil</span>
}

// ConfigDir returns the configuration directory path
func (s *Storage) ConfigDir() string <span class="cov8" title="1">{
        return s.configDir
}</span>

// ProcessesDir returns the processes directory path
func (s *Storage) ProcessesDir() string <span class="cov8" title="1">{
        return filepath.Join(s.configDir, "processes")
}</span>

// LogsDir returns the logs directory path
func (s *Storage) LogsDir() string <span class="cov8" title="1">{
        return filepath.Join(s.configDir, "logs")
}</span>

// PidsDir returns the PIDs directory path
func (s *Storage) PidsDir() string <span class="cov8" title="1">{
        return filepath.Join(s.configDir, "pids")
}</span>

// StateFile returns the path to the state file
func (s *Storage) StateFile() string <span class="cov8" title="1">{
        return filepath.Join(s.configDir, "state.json")
}</span>

// SaveState saves data to the state file
func (s *Storage) SaveState(data interface{}) error <span class="cov8" title="1">{
        file, err := os.Create(s.StateFile())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create state file: %w", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        encoder := json.NewEncoder(file)
        encoder.SetIndent("", "  ")
        if err := encoder.Encode(data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to encode state: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// LoadState loads data from the state file
func (s *Storage) LoadState(data interface{}) error <span class="cov8" title="1">{
        file, err := os.Open(s.StateFile())
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return nil // No state file yet, that's ok
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to open state file: %w", err)</span>
        }
        <span class="cov8" title="1">defer file.Close()

        decoder := json.NewDecoder(file)
        if err := decoder.Decode(data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decode state: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// SavePID saves a process PID to a file
func (s *Storage) SavePID(name string, pid int) error <span class="cov8" title="1">{
        pidFile := filepath.Join(s.PidsDir(), fmt.Sprintf("%s.pid", name))
        return os.WriteFile(pidFile, []byte(fmt.Sprintf("%d", pid)), 0644)
}</span>

// RemovePID removes a process PID file
func (s *Storage) RemovePID(name string) error <span class="cov8" title="1">{
        pidFile := filepath.Join(s.PidsDir(), fmt.Sprintf("%s.pid", name))
        err := os.Remove(pidFile)
        if err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// GetLogFile returns the path for a process log file
func (s *Storage) GetLogFile(name, stream string) string <span class="cov8" title="1">{
        return filepath.Join(s.LogsDir(), fmt.Sprintf("%s-%s.log", name, stream))
}</span>

// MetricsConfig holds configuration for metrics collection
type MetricsConfig struct {
        PollIntervalSeconds int `json:"poll_interval_seconds"`
}

// DefaultMetricsConfig returns the default metrics configuration
func DefaultMetricsConfig() MetricsConfig <span class="cov0" title="0">{
        return MetricsConfig{
                PollIntervalSeconds: 2, // Default to 2 seconds for better performance
        }
}</span>

// SaveMetricsConfig saves metrics configuration
func (s *Storage) SaveMetricsConfig(config MetricsConfig) error <span class="cov0" title="0">{
        return s.SaveState(map[string]interface{}{
                "type":    "metrics_config",
                "config":  config,
                "version": "1.0",
        })
}</span>

// LoadMetricsConfig loads metrics configuration
func (s *Storage) LoadMetricsConfig() (MetricsConfig, error) <span class="cov0" title="0">{
        var data map[string]interface{}
        err := s.LoadState(&amp;data)
        if err != nil </span><span class="cov0" title="0">{
                return DefaultMetricsConfig(), nil // Return defaults if no config exists
        }</span>

        // Check if this is a metrics config
        <span class="cov0" title="0">if data["type"] != "metrics_config" </span><span class="cov0" title="0">{
                return DefaultMetricsConfig(), nil
        }</span>

        <span class="cov0" title="0">configData, ok := data["config"].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return DefaultMetricsConfig(), nil
        }</span>

        <span class="cov0" title="0">config := DefaultMetricsConfig()
        if pollInterval, ok := configData["poll_interval_seconds"].(float64); ok </span><span class="cov0" title="0">{
                config.PollIntervalSeconds = int(pollInterval)
        }</span>

        <span class="cov0" title="0">return config, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package tui

import (
        "fmt"
        "path/filepath"
        "strings"
        "time"

        "github.com/charmbracelet/bubbles/textinput"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/craigderington/prox/internal/process"
        "github.com/craigderington/prox/internal/storage"
)

// Model represents the TUI application state
type Model struct {
        manager      *process.Manager
        collector    *process.MetricsCollector
        storage      *storage.Storage
        processes    []*process.Process
        metrics      map[string]*process.ProcessMetrics
        selected     int
        width        int
        height       int
        err          error
        viewState    string // "dashboard", "monitor", or "logs"
        monitorModel *MonitorModel
        logsModel    *LogsModel
        startInput   textinput.Model
        inputMode    bool // true when user is typing in the start input
        pollInterval int  // metrics polling interval in seconds
}

// Message types for async operations
type (
        processesMsg []*process.Process
        metricsMsg   map[string]*process.ProcessMetrics
        tickMsg      time.Time
        errMsg       error
)

// NewModel creates a new TUI model
func NewModel(manager *process.Manager, storage *storage.Storage) Model <span class="cov0" title="0">{
        ti := textinput.New()
        ti.Placeholder = "Enter command to start (e.g., python app.py --name my-worker, node server.js, ./myapp)"
        ti.CharLimit = 200
        ti.Width = 80

        // Load metrics configuration
        metricsConfig, _ := storage.LoadMetricsConfig()

        return Model{
                manager:      manager,
                collector:    process.NewMetricsCollector(manager),
                storage:      storage,
                processes:    []*process.Process{},
                metrics:      make(map[string]*process.ProcessMetrics),
                selected:     0,
                viewState:    "dashboard",
                monitorModel: nil,
                startInput:   ti,
                inputMode:    false,
                pollInterval: metricsConfig.PollIntervalSeconds,
        }
}</span>

// Init initializes the model
func (m Model) Init() tea.Cmd <span class="cov0" title="0">{
        return tea.Batch(
                fetchProcesses(m.manager),
                tickCmd(m.pollInterval),
        )
}</span>

// Update handles messages and updates the model
func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        // Handle window size for both views
        if msg, ok := msg.(tea.WindowSizeMsg); ok </span><span class="cov0" title="0">{
                m.width = msg.Width
                m.height = msg.Height

                // Propagate to active view
                if m.viewState == "monitor" &amp;&amp; m.monitorModel != nil </span><span class="cov0" title="0">{
                        updatedMonitor, cmd := m.monitorModel.Update(msg)
                        m.monitorModel = &amp;updatedMonitor
                        return m, cmd
                }</span>
                <span class="cov0" title="0">if m.viewState == "logs" &amp;&amp; m.logsModel != nil </span><span class="cov0" title="0">{
                        updatedLogs, cmd := m.logsModel.Update(msg)
                        m.logsModel = &amp;updatedLogs
                        return m, cmd
                }</span>
                <span class="cov0" title="0">return m, nil</span>
        }

        // Route messages based on current view
        <span class="cov0" title="0">if m.viewState != "dashboard" </span><span class="cov0" title="0">{
                return m.updateActiveView(msg)
        }</span>

        // Dashboard view handling
        <span class="cov0" title="0">return m.updateDashboard(msg)</span>
}

// updateDashboard handles dashboard-specific messages
func (m Model) updateDashboard(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        switch msg := msg.(type) </span>{
        case tea.KeyMsg:<span class="cov0" title="0">
                // If in input mode, handle differently
                if m.inputMode </span><span class="cov0" title="0">{
                        switch msg.String() </span>{
                        case "esc":<span class="cov0" title="0">
                                // Exit input mode
                                m.inputMode = false
                                m.startInput.Blur()
                                m.startInput.SetValue("")
                                return m, nil</span>

                        case "enter":<span class="cov0" title="0">
                                // Start process with the entered command
                                command := strings.TrimSpace(m.startInput.Value())
                                if command != "" </span><span class="cov0" title="0">{
                                        m.inputMode = false
                                        m.startInput.Blur()
                                        m.startInput.SetValue("")
                                        return m, startProcess(m.manager, command)
                                }</span>
                                <span class="cov0" title="0">return m, nil</span>

                        default:<span class="cov0" title="0">
                                // Forward key to textinput
                                var cmd tea.Cmd
                                m.startInput, cmd = m.startInput.Update(msg)
                                return m, cmd</span>
                        }
                }

                // Normal mode (not in input mode)
                <span class="cov0" title="0">switch msg.String() </span>{
                case "q", "ctrl+c":<span class="cov0" title="0">
                        return m, tea.Quit</span>

                case "n":<span class="cov0" title="0">
                        // Enter input mode to start a new process
                        m.inputMode = true
                        m.startInput.Focus()
                        return m, nil</span>

                case "up", "k":<span class="cov0" title="0">
                        if m.selected &gt; 0 </span><span class="cov0" title="0">{
                                m.selected--
                        }</span>
                        <span class="cov0" title="0">return m, nil</span>

                case "down", "j":<span class="cov0" title="0">
                        if m.selected &lt; len(m.processes)-1 </span><span class="cov0" title="0">{
                                m.selected++
                        }</span>
                        <span class="cov0" title="0">return m, nil</span>

                case "enter":<span class="cov0" title="0">
                        // Open monitor view for selected process
                        if m.selected &lt; len(m.processes) </span><span class="cov0" title="0">{
                                monitorModel := NewMonitorModel(m.manager, m.storage, m.collector, m.processes, m.metrics, m.selected, m.width, m.height)
                                m.monitorModel = &amp;monitorModel
                                m.viewState = "monitor"
                                return m, monitorModel.Init()
                        }</span>
                        <span class="cov0" title="0">return m, nil</span>

                case "r":<span class="cov0" title="0">
                        // Restart selected process
                        if m.selected &lt; len(m.processes) </span><span class="cov0" title="0">{
                                proc := m.processes[m.selected]
                                return m, restartProcess(m.manager, proc.Name)
                        }</span>
                        <span class="cov0" title="0">return m, nil</span>

                case "s":<span class="cov0" title="0">
                        // Stop selected process
                        if m.selected &lt; len(m.processes) </span><span class="cov0" title="0">{
                                proc := m.processes[m.selected]
                                return m, stopProcess(m.manager, proc.Name)
                        }</span>
                        <span class="cov0" title="0">return m, nil</span>

                case "d":<span class="cov0" title="0">
                        // Delete selected process
                        if m.selected &lt; len(m.processes) </span><span class="cov0" title="0">{
                                proc := m.processes[m.selected]
                                return m, deleteProcess(m.manager, proc.Name)
                        }</span>
                        <span class="cov0" title="0">return m, nil</span>

                case "l":<span class="cov0" title="0">
                        // Open logs view for selected process
                        if m.selected &lt; len(m.processes) </span><span class="cov0" title="0">{
                                proc := m.processes[m.selected]
                                logsModel := NewLogsModel(m.manager, m.storage, proc.Name, m.width, m.height)
                                m.logsModel = &amp;logsModel
                                m.viewState = "logs"
                                return m, logsModel.Init()
                        }</span>
                        <span class="cov0" title="0">return m, nil</span>

                case "R":<span class="cov0" title="0">
                        // Refresh
                        return m, fetchProcesses(m.manager)</span>
                }

        case processesMsg:<span class="cov0" title="0">
                m.processes = msg
                // Adjust selection if needed
                if m.selected &gt;= len(m.processes) </span><span class="cov0" title="0">{
                        m.selected = len(m.processes) - 1
                }</span>
                <span class="cov0" title="0">if m.selected &lt; 0 </span><span class="cov0" title="0">{
                        m.selected = 0
                }</span>
                <span class="cov0" title="0">return m, collectMetrics(m.collector)</span>

        case metricsMsg:<span class="cov0" title="0">
                m.metrics = msg
                return m, nil</span>

        case tickMsg:<span class="cov0" title="0">
                return m, tea.Batch(
                        tickCmd(m.pollInterval),
                        fetchProcesses(m.manager),
                )</span>

        case errMsg:<span class="cov0" title="0">
                m.err = error(msg)
                return m, nil</span>
        }

        <span class="cov0" title="0">return m, nil</span>
}

// updateActiveView handles active view messages
func (m Model) updateActiveView(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        switch m.viewState </span>{
        case "monitor":<span class="cov0" title="0">
                if m.monitorModel == nil </span><span class="cov0" title="0">{
                        m.viewState = "dashboard"
                        return m, nil
                }</span>
        case "logs":<span class="cov0" title="0">
                if m.logsModel == nil </span><span class="cov0" title="0">{
                        m.viewState = "dashboard"
                        return m, nil
                }</span>
        default:<span class="cov0" title="0">
                return m, nil</span>
        }

        <span class="cov0" title="0">switch msg := msg.(type) </span>{
        case tea.KeyMsg:<span class="cov0" title="0">
                switch msg.String() </span>{
                case "q", "ctrl+c", "esc":<span class="cov0" title="0">
                        // Exit active view
                        m.viewState = "dashboard"
                        m.monitorModel = nil
                        m.logsModel = nil
                        return m, nil</span>
                }
        }

        // Forward messages to active model
        <span class="cov0" title="0">switch m.viewState </span>{
        case "monitor":<span class="cov0" title="0">
                updatedMonitor, cmd := m.monitorModel.Update(msg)
                m.monitorModel = &amp;updatedMonitor
                return m, cmd</span>
        case "logs":<span class="cov0" title="0">
                updatedLogs, cmd := m.logsModel.Update(msg)
                m.logsModel = &amp;updatedLogs
                return m, cmd</span>
        }

        <span class="cov0" title="0">return m, nil</span>
}

// View renders the TUI
func (m Model) View() string <span class="cov0" title="0">{
        if m.err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("Error: %v\n", m.err)
        }</span>

        // Route to appropriate view
        <span class="cov0" title="0">switch m.viewState </span>{
        case "monitor":<span class="cov0" title="0">
                if m.monitorModel != nil </span><span class="cov0" title="0">{
                        return m.monitorModel.View()
                }</span>
        case "logs":<span class="cov0" title="0">
                if m.logsModel != nil </span><span class="cov0" title="0">{
                        return m.logsModel.View()
                }</span>
        }

        <span class="cov0" title="0">return renderDashboard(m)</span>
}

// Commands for async operations

func tickCmd(intervalSeconds ...int) tea.Cmd <span class="cov0" title="0">{
        seconds := 2 // Default to 2 seconds
        if len(intervalSeconds) &gt; 0 &amp;&amp; intervalSeconds[0] &gt; 0 </span><span class="cov0" title="0">{
                seconds = intervalSeconds[0]
        }</span>
        <span class="cov0" title="0">return tea.Tick(time.Duration(seconds)*time.Second, func(t time.Time) tea.Msg </span><span class="cov0" title="0">{
                return tickMsg(t)
        }</span>)
}

func fetchProcesses(manager *process.Manager) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                return processesMsg(manager.List())
        }</span>
}

func collectMetrics(collector *process.MetricsCollector) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                return metricsMsg(collector.CollectAllMetrics())
        }</span>
}

func restartProcess(manager *process.Manager, name string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                err := manager.Restart(name)
                if err != nil </span><span class="cov0" title="0">{
                        return errMsg(err)
                }</span>
                <span class="cov0" title="0">return fetchProcesses(manager)()</span>
        }
}

func stopProcess(manager *process.Manager, name string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                err := manager.Stop(name)
                if err != nil </span><span class="cov0" title="0">{
                        return errMsg(err)
                }</span>
                <span class="cov0" title="0">return fetchProcesses(manager)()</span>
        }
}

func deleteProcess(manager *process.Manager, name string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                err := manager.Delete(name)
                if err != nil </span><span class="cov0" title="0">{
                        return errMsg(err)
                }</span>
                <span class="cov0" title="0">return fetchProcesses(manager)()</span>
        }
}

func startProcess(manager *process.Manager, command string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                // Parse the command to extract script, name flag, and args
                parts := strings.Fields(command)
                if len(parts) == 0 </span><span class="cov0" title="0">{
                        return errMsg(fmt.Errorf("empty command"))
                }</span>

                <span class="cov0" title="0">script := parts[0]
                var args []string
                var customName string

                // Parse for --name flag and remaining args
                i := 1
                for i &lt; len(parts) </span><span class="cov0" title="0">{
                        if parts[i] == "--name" || parts[i] == "-n" </span><span class="cov0" title="0">{
                                // Next part is the name
                                if i+1 &lt; len(parts) </span><span class="cov0" title="0">{
                                        customName = parts[i+1]
                                        i += 2
                                        continue</span>
                                }
                                <span class="cov0" title="0">i++</span>
                        } else<span class="cov0" title="0"> {
                                args = append(args, parts[i])
                                i++
                        }</span>
                }

                // Generate a name from the script if not provided
                <span class="cov0" title="0">name := customName
                if name == "" </span><span class="cov0" title="0">{
                        name = script
                        if strings.Contains(name, "/") </span><span class="cov0" title="0">{
                                nameParts := strings.Split(name, "/")
                                name = nameParts[len(nameParts)-1]
                        }</span>
                }

                // Auto-detect interpreter based on file extension
                <span class="cov0" title="0">interpreter := detectInterpreter(script)

                // Create config and start the process with auto-detected interpreter
                config := process.ProcessConfig{
                        Name:        name,
                        Script:      script,
                        Interpreter: interpreter,
                        Args:        args,
                }

                _, err := manager.Start(config)
                if err != nil </span><span class="cov0" title="0">{
                        return errMsg(err)
                }</span>
                <span class="cov0" title="0">return fetchProcesses(manager)()</span>
        }
}

// detectInterpreter detects the interpreter based on file extension
func detectInterpreter(script string) string <span class="cov0" title="0">{
        ext := filepath.Ext(script)
        switch ext </span>{
        case ".js":<span class="cov0" title="0">
                return "node"</span>
        case ".py":<span class="cov0" title="0">
                return "python"</span>
        case ".rb":<span class="cov0" title="0">
                return "ruby"</span>
        case ".sh":<span class="cov0" title="0">
                return "bash"</span>
        default:<span class="cov0" title="0">
                return ""</span> // Direct execution
        }
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package tui

import (
        "fmt"
        "strings"

        "github.com/charmbracelet/lipgloss"
        "github.com/charmbracelet/lipgloss/table"
        "github.com/craigderington/prox/internal/process"
        "github.com/craigderington/prox/internal/version"
)

// renderDashboard renders the main dashboard view
func renderDashboard(m Model) string <span class="cov0" title="0">{
        var b strings.Builder

        // Header (boxed)
        b.WriteString(renderHeader(m))
        b.WriteString("\n")

        // Start process input area (between header and process list)
        b.WriteString(renderStartInput(m))
        b.WriteString("\n")

        // Process table (bordered)
        b.WriteString(renderProcessTable(m))
        b.WriteString("\n")

        // Footer/help (boxed)
        b.WriteString(renderFooter(m))

        return b.String()
}</span>

// renderHeader renders the header with title and stats
func renderHeader(m Model) string <span class="cov0" title="0">{
        // Title on the left
        title := titleStyle.Render("‚ö° prox")

        // Version on the right in muted grey
        versionText := lipgloss.NewStyle().
                Foreground(colorMuted).
                Render(version.Version)

        // Calculate spacing to push version to the right
        titleWidth := lipgloss.Width(title)
        versionWidth := lipgloss.Width(versionText)
        availableWidth := m.width - 6 // Account for borders and padding
        spacingWidth := availableWidth - titleWidth - versionWidth

        spacing := ""
        if spacingWidth &gt; 0 </span><span class="cov0" title="0">{
                spacing = strings.Repeat(" ", spacingWidth)
        }</span>

        // Combine title and version on the same line
        <span class="cov0" title="0">titleLine := lipgloss.JoinHorizontal(lipgloss.Left, title, spacing, versionText)

        // Count processes by status
        online := 0
        stopped := 0
        errored := 0

        for _, proc := range m.processes </span><span class="cov0" title="0">{
                switch proc.Status </span>{
                case process.StatusOnline:<span class="cov0" title="0">
                        online++</span>
                case process.StatusStopped:<span class="cov0" title="0">
                        stopped++</span>
                case process.StatusErrored:<span class="cov0" title="0">
                        errored++</span>
                }
        }

        // Individual stat boxes with color backgrounds
        <span class="cov0" title="0">totalBox := lipgloss.NewStyle().
                Foreground(colorText).
                Background(lipgloss.Color("#313244")).
                Padding(0, 2).
                Render(fmt.Sprintf("Total: %d", len(m.processes)))

        onlineBox := lipgloss.NewStyle().
                Foreground(colorSuccess).
                Background(lipgloss.Color("#0a3a0a")).
                Bold(true).
                Padding(0, 2).
                Render(fmt.Sprintf("‚óè %d Online", online))

        stoppedBox := lipgloss.NewStyle().
                Foreground(colorWarning).
                Background(lipgloss.Color("#3a3000")).
                Padding(0, 2).
                Render(fmt.Sprintf("‚óã %d Stopped", stopped))

        erroredBox := lipgloss.NewStyle().
                Foreground(colorDanger).
                Background(lipgloss.Color("#3a0a0a")).
                Bold(true).
                Padding(0, 2).
                Render(fmt.Sprintf("‚úó %d Errored", errored))

        stats := lipgloss.JoinHorizontal(
                lipgloss.Left,
                totalBox,
                "  ",
                onlineBox,
                "  ",
                stoppedBox,
                "  ",
                erroredBox,
        )

        header := lipgloss.JoinVertical(
                lipgloss.Left,
                titleLine,
                "",
                stats,
        )

        // Box the header with minimal margins
        headerBox := lipgloss.NewStyle().
                BorderStyle(lipgloss.RoundedBorder()).
                BorderForeground(colorBorder).
                Padding(0, 1).
                Width(m.width - 2).
                Render(header)

        return headerBox</span>
}

// renderStartInput renders the start process input area
func renderStartInput(m Model) string <span class="cov0" title="0">{
        label := lipgloss.NewStyle().
                Foreground(colorPrimary).
                Bold(true).
                Render("Start Process:")

        inputBox := lipgloss.NewStyle().
                BorderStyle(lipgloss.RoundedBorder()).
                BorderForeground(func() lipgloss.Color </span><span class="cov0" title="0">{
                        if m.inputMode </span><span class="cov0" title="0">{
                                return colorPrimary
                        }</span>
                        <span class="cov0" title="0">return colorBorder</span>
                }()).
                Padding(0, 1).
                Width(m.width - 2).
                Render(lipgloss.JoinVertical(
                        lipgloss.Left,
                        label,
                        m.startInput.View(),
                ))

        <span class="cov0" title="0">hint := lipgloss.NewStyle().
                Foreground(colorMuted).
                Italic(true).
                Render("Press 'n' to start a new process ‚Ä¢ ESC to cancel ‚Ä¢ ENTER to submit")

        if m.inputMode </span><span class="cov0" title="0">{
                hint = lipgloss.NewStyle().
                        Foreground(colorWarning).
                        Italic(true).
                        Render("Type your command ‚Ä¢ ESC to cancel ‚Ä¢ ENTER to submit")
        }</span>

        <span class="cov0" title="0">return lipgloss.JoinVertical(
                lipgloss.Left,
                inputBox,
                hint,
        )</span>
}

// renderProcessTable renders the process table
func renderProcessTable(m Model) string <span class="cov0" title="0">{
        if len(m.processes) == 0 </span><span class="cov0" title="0">{
                emptyMsg := lipgloss.NewStyle().
                        Foreground(colorMuted).
                        Italic(true).
                        Padding(1, 2).
                        Render("No processes running. Press 'n' to start a new process.")

                return lipgloss.NewStyle().
                        BorderStyle(lipgloss.RoundedBorder()).
                        BorderForeground(colorBorder).
                        Padding(0, 1).
                        Width(m.width - 2).
                        Render(emptyMsg)
        }</span>

        // Build table rows
        <span class="cov0" title="0">rows := [][]string{}
        for i, proc := range m.processes </span><span class="cov0" title="0">{
                metrics := m.metrics[proc.ID]
                rows = append(rows, buildProcessRow(proc, metrics, i == m.selected))
        }</span>

        // Create table with lipgloss table package with rounded borders
        <span class="cov0" title="0">t := table.New().
                Border(lipgloss.RoundedBorder()).
                BorderStyle(lipgloss.NewStyle().Foreground(colorBorder)).
                StyleFunc(func(row, col int) lipgloss.Style </span><span class="cov0" title="0">{
                        // Header row
                        if row == 0 </span><span class="cov0" title="0">{
                                return tableHeaderStyle
                        }</span>

                        // Data rows - styling is now applied directly to cell content
                        <span class="cov0" title="0">return lipgloss.NewStyle()</span>
                }).
                Headers("NAME", "STATUS", "CPU", "MEMORY", "UPTIME", "RESTARTS", "PID").
                Rows(rows...)

        <span class="cov0" title="0">return t.Render()</span>
}

// buildProcessRow creates a row of data for the table
func buildProcessRow(proc *process.Process, metrics *process.ProcessMetrics, selected bool) []string <span class="cov0" title="0">{
        // Base styles
        nameStyle := tableCellStyle
        statusStyle := GetStatusStyle(string(proc.Status))
        cpuStyle := tableCellStyle
        memStyle := tableCellStyle
        uptimeStyle := tableCellStyle
        restartsStyle := tableCellStyle
        pidStyle := tableCellStyle

        // Selected row styling
        if selected </span><span class="cov0" title="0">{
                selectBg := lipgloss.Color("#313244")
                nameStyle = nameStyle.Background(selectBg).Foreground(colorText).Bold(true)
                statusStyle = statusStyle.Background(selectBg).Bold(true)
                cpuStyle = cpuStyle.Background(selectBg).Foreground(colorText).Bold(true)
                memStyle = memStyle.Background(selectBg).Foreground(colorText).Bold(true)
                uptimeStyle = uptimeStyle.Background(selectBg).Foreground(colorText).Bold(true)
                restartsStyle = restartsStyle.Background(selectBg).Foreground(colorText).Bold(true)
                pidStyle = pidStyle.Background(selectBg).Foreground(colorText).Bold(true)
        }</span>

        // Name - add selection indicator
        <span class="cov0" title="0">name := truncate(proc.Name, 18)
        if selected </span><span class="cov0" title="0">{
                name = "‚ñ∂ " + name
        }</span>

        // Status
        <span class="cov0" title="0">status := string(proc.Status)

        // CPU
        cpu := "-"
        if metrics != nil &amp;&amp; proc.Status == process.StatusOnline </span><span class="cov0" title="0">{
                cpu = fmt.Sprintf("%.1f%%", metrics.CPU)
        }</span>

        // Memory
        <span class="cov0" title="0">mem := "-"
        if metrics != nil &amp;&amp; proc.Status == process.StatusOnline </span><span class="cov0" title="0">{
                mem = process.FormatBytes(metrics.Memory)
        }</span>

        // Uptime
        <span class="cov0" title="0">uptime := "-"
        if metrics != nil &amp;&amp; proc.Status == process.StatusOnline </span><span class="cov0" title="0">{
                uptime = process.FormatDuration(metrics.Uptime)
        }</span>

        // Restarts
        <span class="cov0" title="0">restarts := fmt.Sprintf("%d", proc.Restarts)

        // PID
        pid := "-"
        if proc.PID &gt; 0 </span><span class="cov0" title="0">{
                pid = fmt.Sprintf("%d", proc.PID)
        }</span>

        // Apply styles and return
        <span class="cov0" title="0">return []string{
                nameStyle.Render(name),
                statusStyle.Render(status),
                cpuStyle.Render(cpu),
                memStyle.Render(mem),
                uptimeStyle.Render(uptime),
                restartsStyle.Render(restarts),
                pidStyle.Render(pid),
        }</span>
}

// renderFooter renders the footer with keyboard shortcuts
func renderFooter(m Model) string <span class="cov0" title="0">{
        help := []string{
                "n new",
                "‚Üë/k up",
                "‚Üì/j down",
                "enter monitor",
                "l logs",
                "r restart",
                "s stop",
                "d delete",
                "R refresh",
                "q quit",
        }

        helpText := strings.Join(help, " ‚Ä¢ ")

        // Box the footer with minimal margins
        footerBox := lipgloss.NewStyle().
                BorderStyle(lipgloss.RoundedBorder()).
                BorderTop(true).
                BorderForeground(colorBorder).
                Foreground(colorMuted).
                Padding(0, 1).
                Width(m.width - 2).
                Render(helpText)

        return footerBox
}</span>

// truncate truncates a string to the given length
func truncate(s string, max int) string <span class="cov0" title="0">{
        if len(s) &lt;= max </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov0" title="0">return s[:max-3] + "..."</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package tui

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/charmbracelet/bubbles/viewport"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
        "github.com/craigderington/prox/internal/logs"
        "github.com/craigderington/prox/internal/process"
        "github.com/craigderington/prox/internal/storage"
)

const (
        maxLogLines = 1000 // Cap to prevent memory bloat
)

// LogsModel represents the logs view state
type LogsModel struct {
        manager       *process.Manager
        storage       *storage.Storage
        processName   string
        viewport      viewport.Model
        entries       []logs.LogEntry
        totalLogsSeen int // Track total logs seen for incremental updates
        followMode    bool
        loading       bool
        err           error
        writingToFile bool     // Toggle state for continuous writing
        logFile       *os.File // Handle to open log file
        logFilePath   string   // Path to the log file being written
}

// NewLogsModel creates a new logs view model
func NewLogsModel(manager *process.Manager, storage *storage.Storage, processName string, width, height int) LogsModel <span class="cov0" title="0">{
        vp := viewport.New(width-4, height-10) // Leave more room for header
        vp.MouseWheelEnabled = true
        vp.MouseWheelDelta = 3

        return LogsModel{
                manager:       manager,
                storage:       storage,
                processName:   processName,
                viewport:      vp,
                entries:       []logs.LogEntry{},
                totalLogsSeen: 0,
                followMode:    true,
                loading:       true,
                err:           nil,
                writingToFile: false,
                logFile:       nil,
                logFilePath:   "",
        }
}</span>

// Init initializes the logs view
func (m LogsModel) Init() tea.Cmd <span class="cov0" title="0">{
        return loadLogsCmd(m.storage, m.processName, 100)
}</span>

// Update handles messages for the logs view
func (m LogsModel) Update(msg tea.Msg) (LogsModel, tea.Cmd) <span class="cov0" title="0">{
        switch msg := msg.(type) </span>{
        case tea.KeyMsg:<span class="cov0" title="0">
                switch msg.String() </span>{
                case "j", "down":<span class="cov0" title="0">
                        m.viewport.LineDown(1)
                        m.followMode = false
                        return m, nil</span>

                case "k", "up":<span class="cov0" title="0">
                        m.viewport.LineUp(1)
                        m.followMode = false
                        return m, nil</span>

                case "d":<span class="cov0" title="0">
                        m.viewport.HalfViewDown()
                        m.followMode = false
                        return m, nil</span>

                case "u":<span class="cov0" title="0">
                        m.viewport.HalfViewUp()
                        m.followMode = false
                        return m, nil</span>

                case "g":<span class="cov0" title="0">
                        m.viewport.GotoTop()
                        m.followMode = false
                        return m, nil</span>

                case "G":<span class="cov0" title="0">
                        m.viewport.GotoBottom()
                        m.followMode = true
                        return m, nil</span>

                case "f":<span class="cov0" title="0">
                        m.followMode = !m.followMode
                        if m.followMode </span><span class="cov0" title="0">{
                                m.viewport.GotoBottom()
                        }</span>
                        <span class="cov0" title="0">return m, nil</span>

                case "r":<span class="cov0" title="0">
                        // Refresh logs
                        m.entries = []logs.LogEntry{}
                        m.totalLogsSeen = 0
                        m.loading = true
                        return m, loadLogsCmd(m.storage, m.processName, 100)</span>

                case "w":<span class="cov0" title="0">
                        // Toggle continuous writing mode
                        if m.writingToFile </span><span class="cov0" title="0">{
                                // Turn OFF writing
                                if m.logFile != nil </span><span class="cov0" title="0">{
                                        m.logFile.Close()
                                        m.logFile = nil
                                }</span>
                                <span class="cov0" title="0">m.writingToFile = false</span>
                        } else<span class="cov0" title="0"> {
                                // Turn ON writing - create new file
                                timestamp := time.Now().Format("2006-01-02_15-04-05")
                                filename := fmt.Sprintf("%s_logs_%s.txt", m.processName, timestamp)
                                filepath := filepath.Join(".", filename)

                                file, err := os.Create(filepath)
                                if err != nil </span><span class="cov0" title="0">{
                                        m.err = fmt.Errorf("failed to create log file: %w", err)
                                        return m, nil
                                }</span>

                                // Write header
                                <span class="cov0" title="0">file.WriteString("# Logs for process: " + m.processName + "\n")
                                file.WriteString("# Started: " + time.Now().Format(time.RFC3339) + "\n")
                                file.WriteString("# Continuous write mode - logs will be appended in real-time\n\n")

                                // Write existing entries
                                for _, entry := range m.entries </span><span class="cov0" title="0">{
                                        writeLogEntry(file, entry)
                                }</span>

                                <span class="cov0" title="0">m.logFile = file
                                m.logFilePath = filepath
                                m.writingToFile = true</span>
                        }
                        <span class="cov0" title="0">return m, nil</span>
                }

        case tea.WindowSizeMsg:<span class="cov0" title="0">
                m.viewport.Width = msg.Width - 4
                m.viewport.Height = msg.Height - 10
                m.updateViewportContent()
                return m, nil</span>

        case logEntriesMsg:<span class="cov0" title="0">
                if len(msg) &gt; 0 </span><span class="cov0" title="0">{
                        if len(m.entries) == 0 </span><span class="cov0" title="0">{
                                // Initial load
                                m.entries = msg
                                m.totalLogsSeen = len(msg)
                                m.loading = false
                                m.updateViewportContent()
                                if m.followMode </span><span class="cov0" title="0">{
                                        m.viewport.GotoBottom()
                                }</span>
                                // Start continuous tailing after initial load
                                <span class="cov0" title="0">return m, tailLogsCmd(m.storage, m.processName, m.totalLogsSeen)</span>
                        } else<span class="cov0" title="0"> {
                                // Incremental update
                                m.entries = append(m.entries, msg...)
                                m.totalLogsSeen += len(msg)

                                // If writing to file, append new entries
                                if m.writingToFile &amp;&amp; m.logFile != nil </span><span class="cov0" title="0">{
                                        for _, entry := range msg </span><span class="cov0" title="0">{
                                                writeLogEntry(m.logFile, entry)
                                        }</span>
                                }

                                // Cap at max lines
                                <span class="cov0" title="0">if len(m.entries) &gt; maxLogLines </span><span class="cov0" title="0">{
                                        m.entries = m.entries[len(m.entries)-maxLogLines:]
                                        // Don't change totalLogsSeen when capping
                                }</span>

                                <span class="cov0" title="0">m.updateViewportContent()

                                // Ensure we scroll to bottom when following
                                if m.followMode </span><span class="cov0" title="0">{
                                        m.viewport.GotoBottom()
                                }</span>
                        }
                }
                // Continue tailing
                <span class="cov0" title="0">return m, tailLogsCmd(m.storage, m.processName, m.totalLogsSeen)</span>

        case logTickMsg:<span class="cov0" title="0">
                // Continue tailing on tick
                return m, tailLogsCmd(m.storage, m.processName, m.totalLogsSeen)</span>

        case logErrorMsg:<span class="cov0" title="0">
                m.err = error(msg)
                m.loading = false
                return m, nil</span>
        }

        <span class="cov0" title="0">return m, nil</span>
}

// renderLogsHeader renders the header with title and log stats
func renderLogsHeader(m LogsModel) string <span class="cov0" title="0">{
        title := titleStyle.Render("‚ö° prox - Logs")

        // Log stats - more compact
        totalLogs := m.totalLogsSeen
        displayedLogs := len(m.entries)
        followStatus := "OFF"
        if m.followMode </span><span class="cov0" title="0">{
                followStatus = "ON"
        }</span>

        // Single line stats - truncate process name if too long
        <span class="cov0" title="0">processName := m.processName
        if len(processName) &gt; 15 </span><span class="cov0" title="0">{
                processName = processName[:12] + "..."
        }</span>
        <span class="cov0" title="0">statsText := fmt.Sprintf("Process: %s ‚Ä¢ Total: %d ‚Ä¢ Displayed: %d ‚Ä¢ Follow: %s",
                processName, totalLogs, displayedLogs, followStatus)

        stats := lipgloss.NewStyle().
                Foreground(colorMuted).
                Render(statsText)

        header := lipgloss.JoinVertical(
                lipgloss.Left,
                title,
                stats,
        )

        return header</span>
}

// View renders the logs view
func (m LogsModel) View() string <span class="cov0" title="0">{
        var b strings.Builder

        // Header with title and stats (similar to dashboard)
        header := renderLogsHeader(m)

        // Box the header
        headerBox := lipgloss.NewStyle().
                BorderStyle(lipgloss.RoundedBorder()).
                BorderForeground(colorBorder).
                Padding(0, 0). // Reduce padding to save space
                Width(m.viewport.Width + 4).
                Render(header)

        b.WriteString(headerBox)
        b.WriteString("\n")

        // Content - box the viewport/message
        var content string
        if m.loading </span><span class="cov0" title="0">{
                content = lipgloss.NewStyle().
                        Foreground(colorMuted).
                        Padding(2, 4).
                        Render("Loading logs...")
        }</span> else<span class="cov0" title="0"> if m.err != nil </span><span class="cov0" title="0">{
                content = lipgloss.NewStyle().
                        Foreground(colorDanger).
                        Padding(2, 4).
                        Render(fmt.Sprintf("Error: %v", m.err))
        }</span> else<span class="cov0" title="0"> if len(m.entries) == 0 </span><span class="cov0" title="0">{
                emptyMsg := fmt.Sprintf(`No logs available for process '%s'

Process may still be starting or has no output yet.
Try running it for a moment, then press 'r' to refresh.

Press 'esc' or 'q' to go back.`, m.processName)

                content = lipgloss.NewStyle().
                        Foreground(colorMuted).
                        Italic(true).
                        Padding(2, 4).
                        Render(emptyMsg)
        }</span> else<span class="cov0" title="0"> {
                content = m.viewport.View()
        }</span>

        // Box the content
        <span class="cov0" title="0">contentBox := lipgloss.NewStyle().
                BorderStyle(lipgloss.NormalBorder()).
                BorderForeground(colorBorder).
                Padding(0, 1).
                Width(m.viewport.Width + 4).
                Height(m.viewport.Height + 2).
                Render(content)

        b.WriteString(contentBox)
        b.WriteString("\n")

        // Footer with controls
        followStatus := "OFF"
        if m.followMode </span><span class="cov0" title="0">{
                followStatus = lipgloss.NewStyle().
                        Foreground(colorSuccess).
                        Bold(true).
                        Render("ON")
        }</span> else<span class="cov0" title="0"> {
                followStatus = lipgloss.NewStyle().
                        Foreground(colorMuted).
                        Render("OFF")
        }</span>

        // Write status indicator
        <span class="cov0" title="0">writeIndicator := "w write"
        if m.writingToFile </span><span class="cov0" title="0">{
                writeIndicator = lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#FFD700")). // Gold color
                        Bold(true).
                        Render("w WRITING")
        }</span>

        <span class="cov0" title="0">footer := fmt.Sprintf("‚Üë/k up  ‚Üì/j down  g top  G bottom  f follow[%s]  r refresh  %s  esc exit", followStatus, writeIndicator)

        // Box the footer
        footerBox := lipgloss.NewStyle().
                BorderStyle(lipgloss.RoundedBorder()).
                BorderTop(true).
                BorderForeground(colorBorder).
                Foreground(colorMuted).
                Padding(0, 2).
                Width(m.viewport.Width + 4).
                Render(footer)

        b.WriteString(footerBox)

        return b.String()</span>
}

// updateViewportContent rebuilds viewport with colorized lines
func (m *LogsModel) updateViewportContent() <span class="cov0" title="0">{
        lines := make([]string, len(m.entries))

        for i, entry := range m.entries </span><span class="cov0" title="0">{
                lines[i] = formatLogEntry(entry)
        }</span>

        <span class="cov0" title="0">content := strings.Join(lines, "\n")
        m.viewport.SetContent(content)

        // Auto-scroll if in follow mode
        if m.followMode </span><span class="cov0" title="0">{
                m.viewport.GotoBottom()
        }</span>
}

// formatLogEntry colorizes a log entry based on source
func formatLogEntry(entry logs.LogEntry) string <span class="cov0" title="0">{
        var indicator string
        if entry.Source == logs.LogSourceStderr </span><span class="cov0" title="0">{
                indicator = lipgloss.NewStyle().
                        Foreground(colorDanger).
                        Bold(true).
                        Render("[ERR]")
        }</span> else<span class="cov0" title="0"> {
                indicator = lipgloss.NewStyle().
                        Foreground(colorSuccess).
                        Render("[OUT]")
        }</span>

        // Format timestamp
        <span class="cov0" title="0">timeStr := lipgloss.NewStyle().
                Foreground(colorMuted).
                Render(entry.Timestamp.Format("15:04:05"))

        return fmt.Sprintf("%s %s %s", timeStr, indicator, entry.Content)</span>
}

// Messages for log view

type logEntriesMsg []logs.LogEntry
type logErrorMsg error
type logTickMsg time.Time

// Commands for log operations

func loadLogsCmd(storage *storage.Storage, processName string, tailLines int) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                entries, err := logs.MergeLogs(storage, processName, tailLines)
                if err != nil </span><span class="cov0" title="0">{
                        return logErrorMsg(err)
                }</span>
                <span class="cov0" title="0">return logEntriesMsg(entries)</span>
        }
}

func tailLogsCmd(storage *storage.Storage, processName string, currentLineCount int) tea.Cmd <span class="cov0" title="0">{
        return tea.Tick(1*time.Second, func(t time.Time) tea.Msg </span><span class="cov0" title="0">{
                // Read all logs and compare count
                entries, err := logs.MergeLogs(storage, processName, 0) // Read all
                if err != nil </span><span class="cov0" title="0">{
                        return logTickMsg(t)
                }</span>

                // If we have new entries, return them
                <span class="cov0" title="0">if len(entries) &gt; currentLineCount </span><span class="cov0" title="0">{
                        newEntries := entries[currentLineCount:]
                        return logEntriesMsg(newEntries)
                }</span>

                <span class="cov0" title="0">return logTickMsg(t)</span>
        })
}

// writeLogEntry writes a single log entry to the file
func writeLogEntry(file *os.File, entry logs.LogEntry) <span class="cov0" title="0">{
        if file == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">source := "OUT"
        if entry.Source == logs.LogSourceStderr </span><span class="cov0" title="0">{
                source = "ERR"
        }</span>
        <span class="cov0" title="0">line := fmt.Sprintf("[%s] [%s] %s\n",
                entry.Timestamp.Format("2006-01-02 15:04:05"),
                source,
                entry.Content)
        file.WriteString(line)</span>
}

// writeLogsToFile writes the current log entries to a file (one-time snapshot)
// Used by monitor view for quick export
func writeLogsToFile(processName string, entries []logs.LogEntry) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                // Create filename with timestamp
                timestamp := time.Now().Format("2006-01-02_15-04-05")
                filename := fmt.Sprintf("%s_logs_%s.txt", processName, timestamp)

                // Write to current directory
                filepath := filepath.Join(".", filename)

                file, err := os.Create(filepath)
                if err != nil </span><span class="cov0" title="0">{
                        return logErrorMsg(fmt.Errorf("failed to create log file: %w", err))
                }</span>
                <span class="cov0" title="0">defer file.Close()

                // Write header
                file.WriteString(fmt.Sprintf("# Logs for process: %s\n", processName))
                file.WriteString(fmt.Sprintf("# Exported: %s\n", time.Now().Format(time.RFC3339)))
                file.WriteString(fmt.Sprintf("# Total entries: %d\n\n", len(entries)))

                // Write each log entry
                for _, entry := range entries </span><span class="cov0" title="0">{
                        writeLogEntry(file, entry)
                }</span>

                // Return a success message (we'll handle this as a no-op for now)
                <span class="cov0" title="0">return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package tui

import (
        "fmt"
        "strings"
        "time"

        "github.com/charmbracelet/bubbles/viewport"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
        "github.com/craigderington/prox/internal/logs"
        "github.com/craigderington/prox/internal/process"
        "github.com/craigderington/prox/internal/storage"
)

// PanelFocus represents which panel is currently focused
type PanelFocus int

const (
        FocusProcessList PanelFocus = iota
        FocusLogs
        FocusMetrics
        FocusMetadata
)

// MonitorModel represents the 4-panel monitor view (pm2-monit style)
type MonitorModel struct {
        manager          *process.Manager
        storage          *storage.Storage
        collector        *process.MetricsCollector
        processes        []*process.Process
        metrics          map[string]*process.ProcessMetrics
        selected         int
        processName      string
        processViewport  viewport.Model // Viewport for process list
        logViewport      viewport.Model // Viewport for logs
        metricsViewport  viewport.Model // Viewport for metrics
        metadataViewport viewport.Model // Viewport for metadata
        logEntries       []logs.LogEntry
        totalLogsSeen    int
        followMode       bool
        focusedPanel     PanelFocus
        width            int
        height           int
        cpuHistory       []float64
        memHistory       []float64
        netHistory       []float64
        maxHistory       int
        prevNetSent      uint64
        prevNetRecv      uint64
        lastMetricsTime  time.Time
}

// NewMonitorModel creates a new monitor view model
func NewMonitorModel(manager *process.Manager, storage *storage.Storage, collector *process.MetricsCollector, processes []*process.Process, metrics map[string]*process.ProcessMetrics, selected int, width, height int) MonitorModel <span class="cov0" title="0">{
        processName := ""
        if selected &lt; len(processes) </span><span class="cov0" title="0">{
                processName = processes[selected].Name
        }</span>

        // Calculate panel dimensions
        <span class="cov0" title="0">leftWidth := (width / 3) - 4
        rightWidth := (width * 2 / 3) - 4
        topHeight := (height * 2 / 3) - 5 // Reserve space for title + borders
        bottomHeight := (height / 3) - 5

        // Ensure minimum sizes
        if leftWidth &lt; 10 </span><span class="cov0" title="0">{
                leftWidth = 10
        }</span>
        <span class="cov0" title="0">if rightWidth &lt; 10 </span><span class="cov0" title="0">{
                rightWidth = 10
        }</span>
        <span class="cov0" title="0">if topHeight &lt; 3 </span><span class="cov0" title="0">{
                topHeight = 3
        }</span>
        <span class="cov0" title="0">if bottomHeight &lt; 3 </span><span class="cov0" title="0">{
                bottomHeight = 3
        }</span>

        // Initialize viewports for each panel
        // Top row: Process List (left) | Logs (right)
        <span class="cov0" title="0">processVP := viewport.New(leftWidth, topHeight)
        processVP.MouseWheelEnabled = true
        processVP.MouseWheelDelta = 1

        logVP := viewport.New(rightWidth, topHeight)
        logVP.MouseWheelEnabled = true
        logVP.MouseWheelDelta = 3

        // Bottom row: Metadata (left) | Metrics (right) - aligned with top
        metadataVP := viewport.New(leftWidth, bottomHeight)
        metadataVP.MouseWheelEnabled = true
        metadataVP.MouseWheelDelta = 1

        metricsVP := viewport.New(rightWidth, bottomHeight)
        metricsVP.MouseWheelEnabled = true
        metricsVP.MouseWheelDelta = 1

        return MonitorModel{
                manager:          manager,
                storage:          storage,
                collector:        collector,
                processes:        processes,
                metrics:          metrics,
                selected:         selected,
                processName:      processName,
                processViewport:  processVP,
                logViewport:      logVP,
                metricsViewport:  metricsVP,
                metadataViewport: metadataVP,
                logEntries:       []logs.LogEntry{},
                totalLogsSeen:    0,
                followMode:       true,
                focusedPanel:     FocusProcessList,
                width:            width,
                height:           height,
                cpuHistory:       make([]float64, 0, 100),
                memHistory:       make([]float64, 0, 100),
                netHistory:       make([]float64, 0, 100),
                maxHistory:       100,
                prevNetSent:      0,
                prevNetRecv:      0,
                lastMetricsTime:  time.Now(),
        }</span>
}

// Init initializes the monitor view
func (m MonitorModel) Init() tea.Cmd <span class="cov0" title="0">{
        return tea.Batch(
                fetchProcesses(m.manager),
                loadLogsCmd(m.storage, m.processName, 100),
                collectMetrics(m.collector),
                tickCmd(), // Start the ticker for live updates
        )
}</span>

// Update handles messages for the monitor view
func (m MonitorModel) Update(msg tea.Msg) (MonitorModel, tea.Cmd) <span class="cov0" title="0">{
        switch msg := msg.(type) </span>{
        case tea.KeyMsg:<span class="cov0" title="0">
                switch msg.String() </span>{
                case "tab":<span class="cov0" title="0">
                        // Cycle through panels
                        m.focusedPanel = (m.focusedPanel + 1) % 4
                        return m, nil</span>

                case "h", "left":<span class="cov0" title="0">
                        // Move focus to left panel
                        switch m.focusedPanel </span>{
                        case FocusLogs:<span class="cov0" title="0">
                                m.focusedPanel = FocusProcessList</span>
                        case FocusMetrics:<span class="cov0" title="0">
                                m.focusedPanel = FocusMetadata</span>
                        }
                        <span class="cov0" title="0">return m, nil</span>

                case "l", "right":<span class="cov0" title="0">
                        // Move focus to right panel
                        switch m.focusedPanel </span>{
                        case FocusProcessList:<span class="cov0" title="0">
                                m.focusedPanel = FocusLogs</span>
                        case FocusMetadata:<span class="cov0" title="0">
                                m.focusedPanel = FocusMetrics</span>
                        }
                        <span class="cov0" title="0">return m, nil</span>

                case "j", "down":<span class="cov0" title="0">
                        switch m.focusedPanel </span>{
                        case FocusProcessList:<span class="cov0" title="0">
                                // Navigate process list and update selection
                                if m.selected &lt; len(m.processes)-1 </span><span class="cov0" title="0">{
                                        m.selected++
                                        m.processName = m.processes[m.selected].Name
                                        m.updateProcessViewport()
                                        m.updateMetricsViewport()
                                        m.updateMetadataViewport()
                                        // Reload logs for new process
                                        m.logEntries = []logs.LogEntry{}
                                        m.totalLogsSeen = 0
                                        return m, loadLogsCmd(m.storage, m.processName, 100)
                                }</span>
                        case FocusLogs:<span class="cov0" title="0">
                                // Scroll logs viewport
                                m.logViewport.LineDown(1)
                                m.followMode = false</span>
                        case FocusMetrics:<span class="cov0" title="0">
                                // Scroll metrics viewport
                                m.metricsViewport.LineDown(1)</span>
                        case FocusMetadata:<span class="cov0" title="0">
                                // Scroll metadata viewport
                                m.metadataViewport.LineDown(1)</span>
                        }
                        <span class="cov0" title="0">return m, nil</span>

                case "k", "up":<span class="cov0" title="0">
                        switch m.focusedPanel </span>{
                        case FocusProcessList:<span class="cov0" title="0">
                                // Navigate process list and update selection
                                if m.selected &gt; 0 </span><span class="cov0" title="0">{
                                        m.selected--
                                        m.processName = m.processes[m.selected].Name
                                        m.updateProcessViewport()
                                        m.updateMetricsViewport()
                                        m.updateMetadataViewport()
                                        // Reload logs for new process
                                        m.logEntries = []logs.LogEntry{}
                                        m.totalLogsSeen = 0
                                        return m, loadLogsCmd(m.storage, m.processName, 100)
                                }</span>
                        case FocusLogs:<span class="cov0" title="0">
                                // Scroll logs viewport
                                m.logViewport.LineUp(1)
                                m.followMode = false</span>
                        case FocusMetrics:<span class="cov0" title="0">
                                // Scroll metrics viewport
                                m.metricsViewport.LineUp(1)</span>
                        case FocusMetadata:<span class="cov0" title="0">
                                // Scroll metadata viewport
                                m.metadataViewport.LineUp(1)</span>
                        }
                        <span class="cov0" title="0">return m, nil</span>

                case "g":<span class="cov0" title="0">
                        if m.focusedPanel == FocusLogs </span><span class="cov0" title="0">{
                                m.logViewport.GotoTop()
                                m.followMode = false
                        }</span>
                        <span class="cov0" title="0">return m, nil</span>

                case "G":<span class="cov0" title="0">
                        if m.focusedPanel == FocusLogs </span><span class="cov0" title="0">{
                                m.logViewport.GotoBottom()
                                m.followMode = true
                        }</span>
                        <span class="cov0" title="0">return m, nil</span>

                case "f":<span class="cov0" title="0">
                        if m.focusedPanel == FocusLogs </span><span class="cov0" title="0">{
                                m.followMode = !m.followMode
                                if m.followMode </span><span class="cov0" title="0">{
                                        m.logViewport.GotoBottom()
                                }</span>
                        }
                        <span class="cov0" title="0">return m, nil</span>

                case "w":<span class="cov0" title="0">
                        // Write logs to disk (only when logs panel is focused)
                        if m.focusedPanel == FocusLogs </span><span class="cov0" title="0">{
                                return m, writeLogsToFile(m.processName, m.logEntries)
                        }</span>
                        <span class="cov0" title="0">return m, nil</span>

                case "r":<span class="cov0" title="0">
                        // Restart selected process
                        if m.selected &lt; len(m.processes) </span><span class="cov0" title="0">{
                                proc := m.processes[m.selected]
                                if err := m.manager.Restart(proc.ID); err == nil </span><span class="cov0" title="0">{
                                        m.storage.SaveState(m.manager.List())
                                }</span>
                                <span class="cov0" title="0">return m, tea.Batch(
                                        fetchProcesses(m.manager),
                                        collectMetrics(m.collector),
                                )</span>
                        }
                        <span class="cov0" title="0">return m, nil</span>

                case "s":<span class="cov0" title="0">
                        // Stop selected process
                        if m.selected &lt; len(m.processes) </span><span class="cov0" title="0">{
                                proc := m.processes[m.selected]
                                if err := m.manager.Stop(proc.ID); err == nil </span><span class="cov0" title="0">{
                                        m.storage.SaveState(m.manager.List())
                                }</span>
                                <span class="cov0" title="0">return m, tea.Batch(
                                        fetchProcesses(m.manager),
                                        collectMetrics(m.collector),
                                )</span>
                        }
                        <span class="cov0" title="0">return m, nil</span>

                case "d":<span class="cov0" title="0">
                        // Delete selected process
                        if m.selected &lt; len(m.processes) </span><span class="cov0" title="0">{
                                proc := m.processes[m.selected]
                                if err := m.manager.Delete(proc.ID); err == nil </span><span class="cov0" title="0">{
                                        m.storage.SaveState(m.manager.List())
                                        // Adjust selection if needed
                                        if m.selected &gt;= len(m.processes)-1 &amp;&amp; m.selected &gt; 0 </span><span class="cov0" title="0">{
                                                m.selected--
                                        }</span>
                                        // Update process name
                                        <span class="cov0" title="0">if m.selected &lt; len(m.processes) </span><span class="cov0" title="0">{
                                                m.processName = m.processes[m.selected].Name
                                        }</span>
                                }
                                <span class="cov0" title="0">return m, tea.Batch(
                                        fetchProcesses(m.manager),
                                        collectMetrics(m.collector),
                                )</span>
                        }
                        <span class="cov0" title="0">return m, nil</span>
                }

        case tea.WindowSizeMsg:<span class="cov0" title="0">
                m.width = msg.Width
                m.height = msg.Height

                // Recalculate viewport sizes for all panels
                availableHeight := m.height - 4
                leftWidth := (m.width / 3) - 6
                rightWidth := (m.width * 2 / 3) - 6
                topHeight := (availableHeight * 2 / 3) - 6
                bottomHeight := (availableHeight / 3) - 4

                // Ensure minimum sizes
                if leftWidth &lt; 10 </span><span class="cov0" title="0">{
                        leftWidth = 10
                }</span>
                <span class="cov0" title="0">if rightWidth &lt; 10 </span><span class="cov0" title="0">{
                        rightWidth = 10
                }</span>
                <span class="cov0" title="0">if topHeight &lt; 3 </span><span class="cov0" title="0">{
                        topHeight = 3
                }</span>
                <span class="cov0" title="0">if bottomHeight &lt; 3 </span><span class="cov0" title="0">{
                        bottomHeight = 3
                }</span>

                // Update all viewports
                // Top row: Process List (left) | Logs (right)
                <span class="cov0" title="0">m.processViewport.Width = leftWidth
                m.processViewport.Height = topHeight
                m.logViewport.Width = rightWidth
                m.logViewport.Height = topHeight
                // Bottom row: Metadata (left) | Metrics (right) - aligned with top
                m.metadataViewport.Width = leftWidth
                m.metadataViewport.Height = bottomHeight
                m.metricsViewport.Width = rightWidth
                m.metricsViewport.Height = bottomHeight

                // Update viewport contents
                m.updateProcessViewport()
                m.updateLogViewport()
                m.updateMetricsViewport()
                m.updateMetadataViewport()
                return m, nil</span>

        case logEntriesMsg:<span class="cov0" title="0">
                if len(msg) &gt; 0 </span><span class="cov0" title="0">{
                        if len(m.logEntries) == 0 </span><span class="cov0" title="0">{
                                // Initial load
                                m.logEntries = msg
                                m.totalLogsSeen = len(msg)
                                m.updateLogViewport()
                                // Ensure we scroll to bottom on initial load
                                if m.followMode </span><span class="cov0" title="0">{
                                        m.logViewport.GotoBottom()
                                }</span>
                                // Start continuous tailing after initial load
                                <span class="cov0" title="0">return m, tailLogsCmd(m.storage, m.processName, m.totalLogsSeen)</span>
                        } else<span class="cov0" title="0"> {
                                // Incremental update
                                m.logEntries = append(m.logEntries, msg...)
                                m.totalLogsSeen += len(msg)

                                // Cap at max lines
                                if len(m.logEntries) &gt; maxLogLines </span><span class="cov0" title="0">{
                                        m.logEntries = m.logEntries[len(m.logEntries)-maxLogLines:]
                                        // Don't change totalLogsSeen when capping
                                }</span>

                                <span class="cov0" title="0">m.updateLogViewport()
                                // Ensure we scroll to bottom when following
                                if m.followMode </span><span class="cov0" title="0">{
                                        m.logViewport.GotoBottom()
                                }</span>
                        }
                }
                // Continue tailing
                <span class="cov0" title="0">return m, tailLogsCmd(m.storage, m.processName, m.totalLogsSeen)</span>

        case logTickMsg:<span class="cov0" title="0">
                // Continue tailing on tick
                return m, tailLogsCmd(m.storage, m.processName, m.totalLogsSeen)</span>

        case tickMsg:<span class="cov0" title="0">
                // Refresh processes and metrics on each tick
                return m, tea.Batch(
                        tickCmd(),
                        fetchProcesses(m.manager),
                        collectMetrics(m.collector),
                )</span>

        case metricsMsg:<span class="cov0" title="0">
                m.metrics = msg
                // Add to history for sparklines
                if m.selected &lt; len(m.processes) </span><span class="cov0" title="0">{
                        proc := m.processes[m.selected]
                        if metrics := msg[proc.ID]; metrics != nil </span><span class="cov0" title="0">{
                                m.cpuHistory = append(m.cpuHistory, metrics.CPU)
                                m.memHistory = append(m.memHistory, metrics.MemoryPercent)
                                if len(m.cpuHistory) &gt; m.maxHistory </span><span class="cov0" title="0">{
                                        m.cpuHistory = m.cpuHistory[1:]
                                }</span>
                                <span class="cov0" title="0">if len(m.memHistory) &gt; m.maxHistory </span><span class="cov0" title="0">{
                                        m.memHistory = m.memHistory[1:]
                                }</span>

                                // Calculate network rate (bytes/sec)
                                <span class="cov0" title="0">now := time.Now()
                                timeDiff := now.Sub(m.lastMetricsTime).Seconds()
                                if timeDiff &gt; 0 </span><span class="cov0" title="0">{
                                        netRate := float64(metrics.NetSent+metrics.NetRecv-m.prevNetSent-m.prevNetRecv) / timeDiff
                                        m.netHistory = append(m.netHistory, netRate)
                                        if len(m.netHistory) &gt; m.maxHistory </span><span class="cov0" title="0">{
                                                m.netHistory = m.netHistory[1:]
                                        }</span>
                                        <span class="cov0" title="0">m.prevNetSent = metrics.NetSent
                                        m.prevNetRecv = metrics.NetRecv
                                        m.lastMetricsTime = now</span>
                                }
                        }
                }
                <span class="cov0" title="0">m.updateMetricsViewport()
                m.updateMetadataViewport()
                m.updateProcessViewport() // Update process list to show live CPU/Mem
                return m, nil</span>

        case processesMsg:<span class="cov0" title="0">
                m.processes = msg
                m.updateProcessViewport()
                m.updateMetadataViewport()
                return m, nil</span>
        }

        <span class="cov0" title="0">return m, nil</span>
}

// View renders the 4-panel monitor view
func (m MonitorModel) View() string <span class="cov0" title="0">{
        // Simple text header without borders
        header := m.renderSimpleHeader()

        // Calculate viewport dimensions (content area inside borders)
        // Account for header (1 line), help (1 line) and margins
        availableHeight := m.height - 4
        // Account for spacing between panels
        leftWidth := (m.width / 3) - 6
        rightWidth := (m.width * 2 / 3) - 6
        topHeight := (availableHeight * 2 / 3) - 6
        bottomHeight := (availableHeight / 3) - 4

        // Ensure minimum sizes
        if leftWidth &lt; 10 </span><span class="cov0" title="0">{
                leftWidth = 10
        }</span>
        <span class="cov0" title="0">if rightWidth &lt; 10 </span><span class="cov0" title="0">{
                rightWidth = 10
        }</span>
        <span class="cov0" title="0">if topHeight &lt; 3 </span><span class="cov0" title="0">{
                topHeight = 3
        }</span>
        <span class="cov0" title="0">if bottomHeight &lt; 3 </span><span class="cov0" title="0">{
                bottomHeight = 3
        }</span>

        // Render panels (these will add borders and padding)
        // Top row: Process List (left 1/3) | Logs (right 2/3)
        <span class="cov0" title="0">processListPanel := m.renderProcessListPanel(leftWidth, topHeight)
        logsPanel := m.renderLogsPanel(rightWidth, topHeight)
        // Bottom row: Metadata (left 1/3) | Metrics (right 2/3) - aligned with top row
        metadataPanel := m.renderMetadataPanel(leftWidth, bottomHeight)
        metricsPanel := m.renderMetricsPanel(rightWidth, bottomHeight)

        // Top row with spacing
        topRow := lipgloss.JoinHorizontal(
                lipgloss.Top,
                processListPanel,
                " ", // Spacing between panels
                logsPanel,
        )

        // Bottom row with spacing
        bottomRow := lipgloss.JoinHorizontal(
                lipgloss.Top,
                metadataPanel,
                " ", // Spacing between panels
                metricsPanel,
        )

        // Help text - show focused panel controls
        var helpText string
        switch m.focusedPanel </span>{
        case FocusProcessList:<span class="cov0" title="0">
                helpText = "‚Üë/‚Üì/j/k: select ‚Ä¢ h/l: panels ‚Ä¢ r: restart ‚Ä¢ s: stop ‚Ä¢ d: delete ‚Ä¢ esc: back"</span>
        case FocusLogs:<span class="cov0" title="0">
                helpText = "‚Üë/‚Üì/j/k: scroll ‚Ä¢ g/G: top/bottom ‚Ä¢ f: follow ‚Ä¢ w: write ‚Ä¢ h/l: panels ‚Ä¢ r/s/d: controls ‚Ä¢ esc: back"</span>
        default:<span class="cov0" title="0">
                helpText = "‚Üë/‚Üì/j/k: scroll ‚Ä¢ h/l: panels ‚Ä¢ r: restart ‚Ä¢ s: stop ‚Ä¢ d: delete ‚Ä¢ esc: back"</span>
        }

        <span class="cov0" title="0">help := lipgloss.NewStyle().
                Foreground(colorMuted).
                Render(helpText)

        // Build the view properly using Lipgloss
        content := lipgloss.JoinVertical(
                lipgloss.Left,
                header,
                topRow,
                bottomRow,
                help,
        )

        // Apply proper margins/padding
        return lipgloss.NewStyle().
                MarginTop(1).
                MarginBottom(1).
                Render(content)</span>
}

// renderSimpleHeader renders a simple text header without borders
func (m MonitorModel) renderSimpleHeader() string <span class="cov0" title="0">{
        title := titleStyle.Render("‚ö° prox monitor")

        // Show selected process name
        processInfo := ""
        if m.selected &lt; len(m.processes) </span><span class="cov0" title="0">{
                processInfo = lipgloss.NewStyle().
                        Foreground(colorPrimary).
                        Bold(true).
                        Render(fmt.Sprintf("Monitoring: %s", m.processName))
        }</span>

        <span class="cov0" title="0">return lipgloss.JoinHorizontal(
                lipgloss.Left,
                title,
                "  ",
                processInfo,
        )</span>
}

// renderMonitorHeader renders the header for monitor view
func (m MonitorModel) renderMonitorHeader() string <span class="cov0" title="0">{
        title := titleStyle.Render("‚ö° prox monitor")

        // Show selected process name
        processInfo := ""
        if m.selected &lt; len(m.processes) </span><span class="cov0" title="0">{
                processInfo = lipgloss.NewStyle().
                        Foreground(colorPrimary).
                        Bold(true).
                        Render(fmt.Sprintf("Monitoring: %s", m.processName))
        }</span>

        <span class="cov0" title="0">header := lipgloss.JoinHorizontal(
                lipgloss.Left,
                title,
                "  ",
                processInfo,
        )

        // Wrap in a border spanning the full terminal width
        return lipgloss.NewStyle().
                BorderStyle(lipgloss.RoundedBorder()).
                BorderForeground(colorBorder).
                Padding(0, 1).
                Width(m.width - 2).
                Render(header)</span>
}

// renderProcessListPanel renders the process list (top-left)
func (m MonitorModel) renderProcessListPanel(width, height int) string <span class="cov0" title="0">{
        title := "üìã Process List"
        if m.focusedPanel == FocusProcessList </span><span class="cov0" title="0">{
                title = "‚ñ∂ üìã Process List"
        }</span>

        <span class="cov0" title="0">titleBar := lipgloss.NewStyle().
                Foreground(colorPrimary).
                Bold(true).
                Render(title)

        // Highlight border if focused
        borderColor := colorBorder
        if m.focusedPanel == FocusProcessList </span><span class="cov0" title="0">{
                borderColor = colorPrimary
        }</span>

        // Wrap viewport in a bordered box with title
        <span class="cov0" title="0">content := lipgloss.JoinVertical(
                lipgloss.Left,
                titleBar,
                "",
                m.processViewport.View(),
        )

        return lipgloss.NewStyle().
                BorderStyle(lipgloss.RoundedBorder()).
                BorderForeground(borderColor).
                Padding(0, 1).
                Render(content)</span>
}

// renderLogsPanel renders the logs viewer (top-right)
func (m MonitorModel) renderLogsPanel(width, height int) string <span class="cov0" title="0">{
        titleText := fmt.Sprintf("üìú Logs: %s", truncate(m.processName, 20))
        if m.focusedPanel == FocusLogs </span><span class="cov0" title="0">{
                titleText = "‚ñ∂ " + titleText
        }</span>

        <span class="cov0" title="0">followStatus := ""
        if m.followMode </span><span class="cov0" title="0">{
                followStatus = lipgloss.NewStyle().
                        Foreground(colorSuccess).
                        Render(" [FOLLOW]")
        }</span>

        <span class="cov0" title="0">titleBar := lipgloss.NewStyle().
                Foreground(colorPrimary).
                Bold(true).
                Render(titleText + followStatus)

        // Highlight border if focused
        borderColor := colorBorder
        if m.focusedPanel == FocusLogs </span><span class="cov0" title="0">{
                borderColor = colorPrimary
        }</span>

        // Wrap viewport in a bordered box with title
        <span class="cov0" title="0">content := lipgloss.JoinVertical(
                lipgloss.Left,
                titleBar,
                "",
                m.logViewport.View(),
        )

        return lipgloss.NewStyle().
                BorderStyle(lipgloss.RoundedBorder()).
                BorderForeground(borderColor).
                Padding(0, 1).
                Render(content)</span>
}

// renderMetricsPanel renders custom metrics (bottom-right)
func (m MonitorModel) renderMetricsPanel(width, height int) string <span class="cov0" title="0">{
        titleText := "üìà Key CPU &amp; Memory Metrics"
        if m.focusedPanel == FocusMetrics </span><span class="cov0" title="0">{
                titleText = "‚ñ∂ " + titleText
        }</span>

        <span class="cov0" title="0">titleBar := lipgloss.NewStyle().
                Foreground(colorPrimary).
                Bold(true).
                Render(titleText)

        // Highlight border if focused
        borderColor := colorBorder
        if m.focusedPanel == FocusMetrics </span><span class="cov0" title="0">{
                borderColor = colorPrimary
        }</span>

        // Wrap viewport in a bordered box with title
        <span class="cov0" title="0">content := lipgloss.JoinVertical(
                lipgloss.Left,
                titleBar,
                "",
                m.metricsViewport.View(),
        )

        return lipgloss.NewStyle().
                BorderStyle(lipgloss.RoundedBorder()).
                BorderForeground(borderColor).
                Padding(0, 1).
                Render(content)</span>
}

// renderProgressBar creates a colored progress bar like htop
func renderProgressBar(percent float64, width int) string <span class="cov0" title="0">{
        if percent &lt; 0 </span><span class="cov0" title="0">{
                percent = 0
        }</span>
        <span class="cov0" title="0">if percent &gt; 100 </span><span class="cov0" title="0">{
                percent = 100
        }</span>

        // Calculate filled portion
        <span class="cov0" title="0">filled := int(percent / 100.0 * float64(width))
        empty := width - filled

        // Choose color based on percentage
        var barColor lipgloss.Color
        if percent &lt; 50 </span><span class="cov0" title="0">{
                barColor = colorSuccess // Green
        }</span> else<span class="cov0" title="0"> if percent &lt; 80 </span><span class="cov0" title="0">{
                barColor = colorWarning // Yellow
        }</span> else<span class="cov0" title="0"> {
                barColor = colorDanger // Red
        }</span>

        // Build bar with filled and empty sections
        <span class="cov0" title="0">filledBar := lipgloss.NewStyle().
                Foreground(barColor).
                Render(strings.Repeat("‚ñà", filled))

        emptyBar := lipgloss.NewStyle().
                Foreground(colorMuted).
                Render(strings.Repeat("‚ñë", empty))

        return filledBar + emptyBar</span>
}

// renderWaveGraph creates a sparkline graph using block characters (like lazydocker)
// Newest data appears on the RIGHT, oldest on the LEFT (flows right to left)
func renderWaveGraph(data []float64, width int) string <span class="cov0" title="0">{
        if len(data) == 0 </span><span class="cov0" title="0">{
                return strings.Repeat("‚ñÅ", width)
        }</span>

        // Find min and max
        <span class="cov0" title="0">min, max := data[0], data[0]
        for _, v := range data </span><span class="cov0" title="0">{
                if v &lt; min </span><span class="cov0" title="0">{
                        min = v
                }</span>
                <span class="cov0" title="0">if v &gt; max </span><span class="cov0" title="0">{
                        max = v
                }</span>
        }

        // Avoid division by zero
        <span class="cov0" title="0">if max == min </span><span class="cov0" title="0">{
                max = min + 1
        }</span>

        // Block characters for sparkline (8 levels)
        <span class="cov0" title="0">chars := []string{"‚ñÅ", "‚ñÇ", "‚ñÉ", "‚ñÑ", "‚ñÖ", "‚ñÜ", "‚ñá", "‚ñà"}

        var wave strings.Builder

        // If we have less data than width, pad on the left with baseline
        if len(data) &lt; width </span><span class="cov0" title="0">{
                padding := width - len(data)
                for i := 0; i &lt; padding; i++ </span><span class="cov0" title="0">{
                        wave.WriteString("‚ñÅ")
                }</span>
        }

        // Determine how many data points to show
        <span class="cov0" title="0">startIdx := 0
        if len(data) &gt; width </span><span class="cov0" title="0">{
                // Show the most recent 'width' points
                startIdx = len(data) - width
        }</span>

        // Render data points from oldest (left) to newest (right)
        <span class="cov0" title="0">for i := startIdx; i &lt; len(data); i++ </span><span class="cov0" title="0">{
                // Normalize to 0-1
                normalized := (data[i] - min) / (max - min)
                // Map to character index (0-7 for 8 levels)
                charIndex := int(normalized * float64(len(chars)-1))
                if charIndex &lt; 0 </span><span class="cov0" title="0">{
                        charIndex = 0
                }</span>
                <span class="cov0" title="0">if charIndex &gt;= len(chars) </span><span class="cov0" title="0">{
                        charIndex = len(chars) - 1
                }</span>
                <span class="cov0" title="0">wave.WriteString(chars[charIndex])</span>
        }

        <span class="cov0" title="0">return wave.String()</span>
}

// renderMetadataPanel renders process metadata (bottom-left)
func (m MonitorModel) renderMetadataPanel(width, height int) string <span class="cov0" title="0">{
        titleText := "‚ÑπÔ∏è  Metadata"
        if m.focusedPanel == FocusMetadata </span><span class="cov0" title="0">{
                titleText = "‚ñ∂ " + titleText
        }</span>

        <span class="cov0" title="0">titleBar := lipgloss.NewStyle().
                Foreground(colorPrimary).
                Bold(true).
                Render(titleText)

        // Highlight border if focused
        borderColor := colorBorder
        if m.focusedPanel == FocusMetadata </span><span class="cov0" title="0">{
                borderColor = colorPrimary
        }</span>

        // Wrap viewport in a bordered box with title
        <span class="cov0" title="0">content := lipgloss.JoinVertical(
                lipgloss.Left,
                titleBar,
                "",
                m.metadataViewport.View(),
        )

        return lipgloss.NewStyle().
                BorderStyle(lipgloss.RoundedBorder()).
                BorderForeground(borderColor).
                Padding(0, 1).
                Render(content)</span>
}

// updateProcessViewport updates the process list viewport content
func (m *MonitorModel) updateProcessViewport() <span class="cov0" title="0">{
        var lines []string

        for i, proc := range m.processes </span><span class="cov0" title="0">{
                metrics := m.metrics[proc.ID]

                // Status symbol and color
                statusSymbol := "‚óã"
                statusColor := colorMuted
                switch proc.Status </span>{
                case process.StatusOnline:<span class="cov0" title="0">
                        statusSymbol = "‚óè"
                        statusColor = colorSuccess</span>
                case process.StatusErrored:<span class="cov0" title="0">
                        statusSymbol = "‚úó"
                        statusColor = colorDanger</span>
                case process.StatusRestarting:<span class="cov0" title="0">
                        statusSymbol = "‚Üª"
                        statusColor = colorWarning</span>
                }

                // Format line components
                <span class="cov0" title="0">name := truncate(proc.Name, 12)
                mem := "   -   "
                cpu := "  -  "
                if metrics != nil &amp;&amp; proc.Status == process.StatusOnline </span><span class="cov0" title="0">{
                        mem = fmt.Sprintf("%7s", truncate(process.FormatBytes(metrics.Memory), 7))
                        cpu = fmt.Sprintf("%5.1f%%", metrics.CPU)
                }</span>

                // Build the line with selection highlighting
                <span class="cov0" title="0">line := fmt.Sprintf("%s %s  %s  %s",
                        lipgloss.NewStyle().Foreground(statusColor).Render(statusSymbol),
                        name,
                        mem,
                        cpu,
                )

                // Highlight selected process
                if i == m.selected </span><span class="cov0" title="0">{
                        line = lipgloss.NewStyle().
                                Foreground(colorPrimary).
                                Bold(true).
                                Render("‚ñ∂ " + line)
                }</span> else<span class="cov0" title="0"> {
                        line = "  " + line
                }</span>

                <span class="cov0" title="0">lines = append(lines, line)</span>
        }

        <span class="cov0" title="0">if len(lines) == 0 </span><span class="cov0" title="0">{
                lines = append(lines, lipgloss.NewStyle().
                        Foreground(colorMuted).
                        Render("No processes"))
        }</span>

        <span class="cov0" title="0">content := strings.Join(lines, "\n")
        m.processViewport.SetContent(content)</span>
}

// updateLogViewport updates the log viewport content
func (m *MonitorModel) updateLogViewport() <span class="cov0" title="0">{
        var lines []string

        if len(m.logEntries) == 0 </span><span class="cov0" title="0">{
                lines = append(lines, lipgloss.NewStyle().
                        Foreground(colorMuted).
                        Render("No logs available"))
        }</span> else<span class="cov0" title="0"> {
                for _, entry := range m.logEntries </span><span class="cov0" title="0">{
                        lines = append(lines, formatLogEntry(entry))
                }</span>
        }

        <span class="cov0" title="0">content := strings.Join(lines, "\n")
        m.logViewport.SetContent(content)

        // Auto-scroll if in follow mode
        if m.followMode </span><span class="cov0" title="0">{
                m.logViewport.GotoBottom()
        }</span>
}

// updateMetricsViewport updates the metrics viewport content
func (m *MonitorModel) updateMetricsViewport() <span class="cov0" title="0">{
        var proc *process.Process
        if m.selected &lt; len(m.processes) </span><span class="cov0" title="0">{
                proc = m.processes[m.selected]
        }</span>

        <span class="cov0" title="0">var content string
        if proc != nil </span><span class="cov0" title="0">{
                metrics := m.metrics[proc.ID]
                if metrics != nil &amp;&amp; proc.Status == process.StatusOnline </span><span class="cov0" title="0">{
                        // Calculate percentages
                        cpuPercent := metrics.CPU
                        memPercent := metrics.MemoryPercent

                        // Calculate sparkline width - use full viewport width
                        sparkWidth := m.metricsViewport.Width
                        if sparkWidth &lt; 20 </span><span class="cov0" title="0">{
                                sparkWidth = 20
                        }</span>

                        // Create wave graphs
                        <span class="cov0" title="0">cpuSpark := renderWaveGraph(m.cpuHistory, sparkWidth)
                        memSpark := renderWaveGraph(m.memHistory, sparkWidth)
                        netSpark := renderWaveGraph(m.netHistory, sparkWidth)

                        // Format labels
                        cpuLabel := fmt.Sprintf("CPU: %.1f%%", cpuPercent)
                        memLabel := fmt.Sprintf("Mem: %.1f%%", memPercent)
                        netRate := float64(metrics.NetSent + metrics.NetRecv)
                        if len(m.netHistory) &gt; 0 </span><span class="cov0" title="0">{
                                netRate = m.netHistory[len(m.netHistory)-1]
                        }</span>
                        <span class="cov0" title="0">netLabel := fmt.Sprintf("Net: %s/s", process.FormatBytes(uint64(netRate)))

                        // Build content with ONLY full-width sparklines
                        content = fmt.Sprintf("%s\n%s\n\n%s\n%s\n\n%s\n%s\n\n%s %s\n%s %d",
                                lipgloss.NewStyle().Foreground(colorSuccess).Bold(true).Render(cpuLabel),
                                lipgloss.NewStyle().Foreground(colorSuccess).Render(cpuSpark),
                                lipgloss.NewStyle().Foreground(colorWarning).Bold(true).Render(memLabel),
                                lipgloss.NewStyle().Foreground(colorWarning).Render(memSpark),
                                lipgloss.NewStyle().Foreground(colorPrimary).Bold(true).Render(netLabel),
                                lipgloss.NewStyle().Foreground(colorPrimary).Render(netSpark),
                                lipgloss.NewStyle().Foreground(colorText).Render("Uptime:"),
                                lipgloss.NewStyle().Foreground(colorText).Render(process.FormatDuration(metrics.Uptime)),
                                lipgloss.NewStyle().Foreground(colorText).Render("Restarts:"),
                                proc.Restarts,
                        )</span>
                } else<span class="cov0" title="0"> {
                        content = lipgloss.NewStyle().
                                Foreground(colorMuted).
                                Render("Process not running")
                }</span>
        } else<span class="cov0" title="0"> {
                content = lipgloss.NewStyle().
                        Foreground(colorMuted).
                        Render("No process selected")
        }</span>

        <span class="cov0" title="0">m.metricsViewport.SetContent(content)</span>
}

// updateMetadataViewport updates the metadata viewport content
func (m *MonitorModel) updateMetadataViewport() <span class="cov0" title="0">{
        var proc *process.Process
        if m.selected &lt; len(m.processes) </span><span class="cov0" title="0">{
                proc = m.processes[m.selected]
        }</span>

        <span class="cov0" title="0">var content string
        if proc != nil </span><span class="cov0" title="0">{
                // Truncate long paths to fit in the viewport
                maxFieldWidth := m.metadataViewport.Width - 12
                if maxFieldWidth &lt; 10 </span><span class="cov0" title="0">{
                        maxFieldWidth = 10
                }</span>

                <span class="cov0" title="0">lines := []string{
                        fmt.Sprintf("Name:     %s", truncate(proc.Name, maxFieldWidth)),
                        fmt.Sprintf("Restarts: %d", proc.Restarts),
                        fmt.Sprintf("Status:   %s", proc.Status),
                        fmt.Sprintf("Script:   %s", truncate(proc.Script, maxFieldWidth)),
                        fmt.Sprintf("Interp:   %s", func() string </span><span class="cov0" title="0">{
                                if proc.Interpreter != "" </span><span class="cov0" title="0">{
                                        return proc.Interpreter
                                }</span>
                                <span class="cov0" title="0">return "N/A"</span>
                        }()),
                        fmt.Sprintf("PID:      %d", proc.PID),
                        fmt.Sprintf("Cwd:      %s", truncate(proc.Cwd, maxFieldWidth)),
                }

                // Pad each line to the full viewport width
                <span class="cov0" title="0">paddedLines := make([]string, len(lines))
                for i, line := range lines </span><span class="cov0" title="0">{
                        paddedLines[i] = lipgloss.NewStyle().Width(m.metadataViewport.Width).Render(line)
                }</span>

                <span class="cov0" title="0">content = lipgloss.NewStyle().Foreground(colorText).Render(strings.Join(paddedLines, "\n"))</span>
        } else<span class="cov0" title="0"> {
                content = lipgloss.NewStyle().
                        Foreground(colorMuted).
                        Width(m.metadataViewport.Width).
                        Render("No process selected")
        }</span>

        <span class="cov0" title="0">m.metadataViewport.SetContent(content)</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package tui

import (
        "github.com/charmbracelet/lipgloss"
)

var (
        // Color palette
        colorPrimary = lipgloss.Color("#00D9FF") // Cyan/electric blue
        colorSuccess = lipgloss.Color("#00FF87") // Green
        colorWarning = lipgloss.Color("#FFD700") // Yellow
        colorDanger  = lipgloss.Color("#FF5F87") // Red
        colorMuted   = lipgloss.Color("#6C7086") // Gray
        colorBorder  = lipgloss.Color("#45475A") // Dark gray
        colorText    = lipgloss.Color("#CDD6F4") // Light text

        // Title style
        titleStyle = lipgloss.NewStyle().
                        Foreground(colorPrimary).
                        Bold(true).
                        Padding(0, 1)

        // Status styles
        statusOnlineStyle = lipgloss.NewStyle().
                                Foreground(colorSuccess).
                                Bold(true).
                                Padding(0, 1)

        statusStoppedStyle = lipgloss.NewStyle().
                                Foreground(colorWarning).
                                Padding(0, 1)

        statusErroredStyle = lipgloss.NewStyle().
                                Foreground(colorDanger).
                                Bold(true).
                                Padding(0, 1)

        statusRestartingStyle = lipgloss.NewStyle().
                                Foreground(colorWarning).
                                Bold(true).
                                Padding(0, 1)

        // Table styles
        tableHeaderStyle = lipgloss.NewStyle().
                                Foreground(colorPrimary).
                                Bold(true).
                                Align(lipgloss.Left).
                                Padding(0, 1)

        tableCellStyle = lipgloss.NewStyle().
                        Foreground(colorText).
                        Padding(0, 1)
)

// GetStatusStyle returns the style for a given status
func GetStatusStyle(status string) lipgloss.Style <span class="cov0" title="0">{
        switch status </span>{
        case "online":<span class="cov0" title="0">
                return statusOnlineStyle</span>
        case "stopped":<span class="cov0" title="0">
                return statusStoppedStyle</span>
        case "errored":<span class="cov0" title="0">
                return statusErroredStyle</span>
        case "restarting", "stopping":<span class="cov0" title="0">
                return statusRestartingStyle</span>
        default:<span class="cov0" title="0">
                return tableCellStyle</span>
        }
}

// StatusIndicator returns a styled status indicator
func StatusIndicator(status string) string <span class="cov0" title="0">{
        var symbol string
        switch status </span>{
        case "online":<span class="cov0" title="0">
                symbol = "‚óè"</span>
        case "stopped":<span class="cov0" title="0">
                symbol = "‚óã"</span>
        case "errored":<span class="cov0" title="0">
                symbol = "‚úó"</span>
        case "restarting":<span class="cov0" title="0">
                symbol = "‚Üª"</span>
        case "stopping":<span class="cov0" title="0">
                symbol = "‚èπ"</span>
        default:<span class="cov0" title="0">
                symbol = "?"</span>
        }
        <span class="cov0" title="0">return GetStatusStyle(status).Render(symbol + " " + status)</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package main

import "github.com/craigderington/prox/cmd"

func main() <span class="cov0" title="0">{
        cmd.Execute()
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
